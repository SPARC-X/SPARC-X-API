{
 "sparc_version": "2025.04.24",
 "categories": [
  "system",
  "scf",
  "electrostatics",
  "stress calculation",
  "qmd",
  "structural relaxation",
  "band structure",
  "print options",
  "parallelization options",
  "orbital free dft",
  "socket communication",
  "spectral quadrature",
  "cyclix",
  "mlff"
 ],
 "parameters": {
  "ATOM_TYPE": {
   "symbol": "ATOM_TYPE",
   "label": "ATOM_TYPE",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "ATOM_TYPE: Fe",
   "description": "Atomic type symbol.",
   "remark": "The atomic type symbol can be attached with a number, e.g., Fe1 and Fe2. This feature is useful if one needs to provide two different pseudopotential files (PSEUDO_POT) for the same element.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Atomic type symbol.",
   "remark_raw": "The atomic type symbol can be attached with a number, e.g., Fe1 and Fe2. This feature is useful if one needs to provide two different pseudopotential files (\\hyperlink{PSEUDO_POT}{\\texttt{PSEUDO\\_POT}}) for the same element.",
   "category": "system"
  },
  "BAND_STRUCTURE": {
   "symbol": "BAND_STRUCTURE",
   "label": "BAND_STRUCTURE",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "BAND_STRUCTURE: 1",
   "description": "Flag for calculation of the band structure.",
   "remark": "",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for calculation of the band structure.",
   "remark_raw": "%",
   "category": "band structure"
  },
  "BC": {
   "symbol": "BC",
   "label": "BC",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "BC: P D D",
   "description": "A set of three whitespace delimited characters specifying the boundary conditions in the lattice vector directions, respectively. P represents periodic boundary conditions and D represents Dirichlet boundary conditions.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "A set of three whitespace delimited characters specifying the boundary conditions in the lattice vector directions, respectively. \\texttt{P} represents periodic boundary conditions and \\texttt{D} represents Dirichlet boundary conditions.",
   "remark_raw": "",
   "remark": "",
   "category": "system"
  },
  "CALC_PRES": {
   "symbol": "CALC_PRES",
   "label": "CALC_PRES",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "CALC_PRES: 1",
   "description": "Flag for calculation of the pressure.",
   "remark": "Pressure is directly calculated, without calculation of the stress tensor.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for calculation of the pressure.",
   "remark_raw": "Pressure is directly calculated, without calculation of the stress tensor.",
   "category": "stress calculation"
  },
  "CALC_STRESS": {
   "symbol": "CALC_STRESS",
   "label": "CALC_STRESS",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "CALC_STRESS: 1",
   "description": "Flag for calculation of the Hellmann-Feynman stress tensor (in cartesian coordinates).",
   "remark": "",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for calculation of the Hellmann-Feynman stress tensor (in cartesian coordinates).",
   "remark_raw": "%",
   "category": "stress calculation"
  },
  "CELL": {
   "symbol": "CELL",
   "label": "CELL",
   "type": "double array",
   "default": null,
   "unit": "Bohr",
   "example": "CELL: 10.20 11.21 7.58",
   "description": "A set of three whitespace delimited values specifying the cell lengths in the lattice vector (LATVEC) directions, respectively.",
   "remark": "Note that CELL ignores the lengths of the lattice vectors specified in the .inpt file and only treats them as unit vectors. LATVEC_SCALE and CELL cannot be specified simultaneously.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "A set of three whitespace delimited values specifying the cell lengths in the lattice vector (\\hyperlink{LATVEC}{\\texttt{LATVEC}}) directions, respectively.",
   "remark_raw": "Note that \\hyperlink{CELL}{\\texttt{CELL}} ignores the lengths of the lattice vectors specified in the \\texttt{.inpt} file and only treats them as unit vectors. \\hyperlink{LATVEC_SCALE}{\\texttt{LATVEC\\_SCALE}} and \\hyperlink{CELL}{\\texttt{CELL}} cannot be specified simultaneously.",
   "category": "system"
  },
  "CHEB_DEGREE": {
   "symbol": "CHEB_DEGREE",
   "label": "CHEB_DEGREE",
   "type": "integer",
   "default": "auto",
   "unit": "No unit",
   "example": "CHEB_DEGEE: 25",
   "description": "Degree of polynomial used for Chebyshev filtering.",
   "remark": "For larger mesh-sizes, smaller values of CHEB_DEGREE are generally more efficient, and vice-versa.",
   "allow_bool_input": false,
   "default_remark": "Automatically set.",
   "description_raw": "Degree of polynomial used for Chebyshev filtering.",
   "remark_raw": "For larger mesh-sizes, smaller values of \\texttt{CHEB\\_DEGREE} are generally more efficient, and vice-versa.",
   "category": "scf"
  },
  "CHEFSI_BOUND_FLAG": {
   "symbol": "CHEFSI_BOUND_FLAG",
   "label": "CHEFSI_BOUND_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "CHEFSI_BOUND_FLAG: 1",
   "description": "Flag to recalculate the bounds for Chebyshev filtering. If set to 0, then only for the very first SCF will the upper bound be evaluated based on the maximum eigenvalue using Lanczos algorithm, and the upper bound will be the same for the rest steps. If set to 1, the upper bound will be reevaluated for every SCF.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to recalculate the bounds for Chebyshev filtering. If set to $0$, then only for the very first SCF will the upper bound be evaluated based on the maximum eigenvalue using Lanczos algorithm, and the upper bound will be the same for the rest steps. If set to $1$, the upper bound will be reevaluated for every SCF.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "COORD": {
   "symbol": "COORD",
   "label": "COORD",
   "type": "double array",
   "default": null,
   "unit": "Bohr",
   "example": "COORD: 0.0 0.0 0.0 \n2.5 2.5 2.5",
   "description": "The Cartesian coordinates of atoms of a ATOM_TYPE specified before this variable. If the coordinates are outside the fundamental domain (see CELL and LATVEC) in the periodic directions (see BC), it will be automatically mapped back to the domain.",
   "remark": "For a system with different types of atoms, one has to specify the coordinates for every ATOM_TYPE. One can also specify the coordinates of the atoms using COORD_FRAC.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The Cartesian coordinates of atoms of a \\hyperlink{ATOM_TYPE}{\\texttt{ATOM\\_TYPE}} specified before this variable. If the coordinates are outside the fundamental domain (see \\hyperlink{CELL}{\\texttt{CELL}} and \\hyperlink{LATVEC}{\\texttt{LATVEC}}) in the periodic directions (see \\hyperlink{BC}{\\texttt{BC}}), it will be automatically mapped back to the domain.",
   "remark_raw": "For a system with different types of atoms, one has to specify the coordinates for every \\hyperlink{ATOM_TYPE}{\\texttt{ATOM\\_TYPE}}. One can also specify the coordinates of the atoms using \\hyperlink{COORD_FRAC}{\\texttt{COORD\\_FRAC}}.",
   "category": "system"
  },
  "COORD_FRAC": {
   "symbol": "COORD_FRAC",
   "label": "COORD_FRAC",
   "type": "double array",
   "default": null,
   "unit": "None",
   "example": "COORD_FRAC: 0.5 0.5 0.0 \n0.0 0.5 0.5",
   "description": "The fractional coordinates of atoms of a ATOM_TYPE specified before this variable. COORD_FRAC(i,j) x CELL(j), (j = 1,2,3) gives the coordinate of the i^th atom along the j^th LATVEC direction. If the coordinates are outside the fundamental domain (see CELL and LATVEC) in the periodic directions (see BC), it will be automatically mapped back to the domain.",
   "remark": "For a system with different types of atoms, one has to specify the coordinates for every ATOM_TYPE. One can also specify the coordinates of the atoms using COORD.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The fractional coordinates of atoms of a \\hyperlink{ATOM_TYPE}{\\texttt{ATOM\\_TYPE}} specified before this variable. \\texttt{COORD\\_FRAC}$(i,j)$ $\\times$ \\hyperlink{CELL}{\\texttt{CELL}}$(j)$, $(j = 1,2,3)$ gives the coordinate of the $i^{th}$ atom along the $j^{th}$ \\hyperlink{LATVEC}{\\texttt{LATVEC}} direction. If the coordinates are outside the fundamental domain (see \\hyperlink{CELL}{\\texttt{CELL}} and \\hyperlink{LATVEC}{\\texttt{LATVEC}}) in the periodic directions (see \\hyperlink{BC}{\\texttt{BC}}), it will be automatically mapped back to the domain.",
   "remark_raw": "For a system with different types of atoms, one has to specify the coordinates for every \\hyperlink{ATOM_TYPE}{\\texttt{ATOM\\_TYPE}}. One can also specify the coordinates of the atoms using \\hyperlink{COORD}{\\texttt{COORD}}.",
   "category": "system"
  },
  "D3_CN_THR": {
   "symbol": "D3_CN_THR",
   "label": "D3_CN_THR",
   "type": "double",
   "default": 625.0,
   "unit": "Bohr$^2$",
   "example": "D3_CN_THR: 1600",
   "description": "Square of cut-off radius for calculating CN value of every atom and DFT-D3 correction between three atoms",
   "remark": "Only applicable when DFT-D3 correction D3_FLAG is used.\nD3_CN_THR should be smaller or equal to cutoff radius of DFT-D3 correction cutoff radius, D3_RTHR.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{625}",
   "description_raw": "Square of cut-off radius for calculating CN value of every atom and DFT-D3 correction between three atoms",
   "remark_raw": "Only applicable when DFT-D3 correction \\hyperlink{D3_FLAG}{\\texttt{D3\\_FLAG}} is used.\n\nD3\\_CN\\_THR should be smaller or equal to cutoff radius of DFT-D3 correction cutoff radius, \\hyperlink{D3_RTHR}{\\texttt{D3\\_RTHR}}.",
   "category": "system"
  },
  "D3_FLAG": {
   "symbol": "D3_FLAG",
   "label": "D3_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "D3_FLAG: 1",
   "description": "Flag for adding Grimme\u2019s DFT-D3 correction on the result",
   "remark": "Only active when using GGA-PBE, GGA-RPBE and GGA-PBEsol.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{0}",
   "description_raw": "Flag for adding Grimme\u2019s DFT-D3 correction on the result",
   "remark_raw": "Only active when using GGA-PBE, GGA-RPBE and GGA-PBEsol.",
   "category": "system"
  },
  "D3_RTHR": {
   "symbol": "D3_RTHR",
   "label": "D3_RTHR",
   "type": "double",
   "default": 1600.0,
   "unit": "Bohr$^2$",
   "example": "D3_RTHR: 9000",
   "description": "Square of cut-off radius for calculating DFT-D3 correction between two atoms",
   "remark": "Only applicable when DFT-D3 correction D3_FLAG is used.\nD3_RTHR should be larger or equal to cutoff radius of CN coefficient, D3_CN_THR.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{1600}",
   "description_raw": "Square of cut-off radius for calculating DFT-D3 correction between two atoms",
   "remark_raw": "Only applicable when DFT-D3 correction \\hyperlink{D3_FLAG}{\\texttt{D3\\_FLAG}} is used.\n\nD3\\_RTHR should be larger or equal to cutoff radius of CN coefficient, \\hyperlink{D3_CN_THR}{\\texttt{D3\\_CN\\_THR}}.",
   "category": "system"
  },
  "ECUT": {
   "symbol": "ECUT",
   "label": "ECUT",
   "type": "double",
   "default": null,
   "unit": "Ha",
   "example": "ECUT: 30",
   "description": "Equivalent plane-wave energy cutoff, based on which MESH_SPACING will be automatically calculated.",
   "remark": "This is not exact, but rather an estimate. ECUT, MESH_SPACING, FD_GRID cannot be specified simultaneously.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Equivalent plane-wave energy cutoff, based on which \\hyperlink{MESH_SPACING}{\\texttt{MESH\\_SPACING}} will be automatically calculated.",
   "remark_raw": "This is not exact, but rather an estimate. \\hyperlink{ECUT}{\\texttt{ECUT}}, \\hyperlink{MESH_SPACING}{\\texttt{MESH\\_SPACING}}, \\hyperlink{FD_GRID}{\\texttt{FD\\_GRID}} cannot be specified simultaneously.",
   "category": "system"
  },
  "EIG_PARAL_BLKSZ": {
   "symbol": "EIG_PARAL_BLKSZ",
   "label": "EIG_PARAL_BLKSZ",
   "type": "integer",
   "default": 128,
   "unit": "No unit",
   "example": "EIG_PARAL_BLKSZ: 64",
   "description": "Block size for the distribution of matrix in block-cyclic format in a parallel algorithm for solving the subspace eigenproblem.",
   "allow_bool_input": false,
   "default_remark": "128",
   "description_raw": "Block size for the distribution of matrix in block-cyclic format in a parallel algorithm for solving the subspace eigenproblem.",
   "remark_raw": "",
   "remark": "",
   "category": "parallelization options"
  },
  "EIG_PARAL_MAXNP": {
   "symbol": "EIG_PARAL_MAXNP",
   "label": "EIG_PARAL_MAXNP",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "EIG_PARAL_MAXNP: 36",
   "description": "Maximum number of processors used in parallel eigensolver. The number is machine dependent. Users could provide their own value for best performance.",
   "allow_bool_input": false,
   "default_remark": "Generated by a linear model.",
   "description_raw": "Maximum number of processors used in parallel eigensolver. The number is machine dependent. Users could provide their own value for best performance.",
   "remark_raw": "",
   "remark": "",
   "category": "parallelization options"
  },
  "EIG_PARAL_ORFAC": {
   "symbol": "EIG_PARAL_ORFAC",
   "label": "EIG_PARAL_ORFAC",
   "type": "double",
   "default": 0.0,
   "unit": "No unit",
   "example": "EIG_PARAL_ORFAC: 0.001",
   "description": "Specifies which eigenvectors should be reorthogonalized when using the parallel eigensolver \np?syevx \nor \np?sygvx \nfor solving the subspace eigenproblem. \nThe parallel eigensolvers can be turned on using the EIG_SERIAL_MAXNS flag.\nNo reorthogonalization will be done if EIG_PARAL_ORFAC equals zero. A default value of 0.001 is used if EIG_PARAL_ORFAC is negative. \nNote that reorthogonalization of eigenvectors is extremely time-consuming.",
   "allow_bool_input": false,
   "default_remark": "0.0",
   "description_raw": "Specifies which eigenvectors should be reorthogonalized when using the parallel eigensolver \n\\href{https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/scalapack-routines/scalapack-driver-routines/p-syevx.html}{\\texttt{p?syevx}} \nor \n\\href{https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/scalapack-routines/scalapack-driver-routines/p-sygvx.html}{\\texttt{p?sygvx}} \nfor solving the subspace eigenproblem. \nThe parallel eigensolvers can be turned on using the \\hyperlink{EIG_SERIAL_MAXNS}{\\texttt{EIG\\_SERIAL\\_MAXNS}} flag.\nNo reorthogonalization will be done if \\texttt{EIG\\_PARAL\\_ORFAC} equals zero. A default value of $0.001$ is used if \\texttt{EIG\\_PARAL\\_ORFAC} is negative. \nNote that reorthogonalization of eigenvectors is extremely time-consuming.\n% See the corresponding documentation for more details.",
   "remark_raw": "",
   "remark": "",
   "category": "parallelization options"
  },
  "EIG_SERIAL_MAXNS": {
   "symbol": "EIG_SERIAL_MAXNS",
   "label": "EIG_SERIAL_MAXNS",
   "type": "integer",
   "default": 2000,
   "unit": "No unit",
   "example": "EIG_SERIAL_MAXNS: 1000",
   "description": "Maximum NSTATES value up to which a serial algorithm will be used to solve the subspace eigenproblem.",
   "remark": "If one wants to use a parallel algorithm to solve the subspace eigenproblem for all cases, simply set EIG_SERIAL_MAXNS to 0. Alternatively, set EIG_SERIAL_MAXNS to a very large value to always use serial algorithm.",
   "allow_bool_input": false,
   "default_remark": "2000",
   "description_raw": "Maximum \\hyperlink{NSTATES}{\\texttt{NSTATES}} value up to which a serial algorithm will be used to solve the subspace eigenproblem.",
   "remark_raw": "If one wants to use a parallel algorithm to solve the subspace eigenproblem for all cases, simply set \\texttt{EIG\\_SERIAL\\_MAXNS} to $0$. Alternatively, set \\texttt{EIG\\_SERIAL\\_MAXNS} to a very large value to always use serial algorithm.",
   "category": "parallelization options"
  },
  "ELEC_TEMP": {
   "symbol": "ELEC_TEMP",
   "label": "ELEC_TEMP",
   "type": "double",
   "default": null,
   "unit": "Kelvin",
   "example": "ELEC_TEMP: 315.775",
   "description": "Electronic temperature.",
   "remark": "This is equivalent to setting SMEARING (0.001 Ha = 315.775 Kelvin).",
   "allow_bool_input": false,
   "default_remark": "2320.904 for \\texttt{gaussian} \\\\\n1160.452 for \\texttt{fermi-dirac}",
   "description_raw": "Electronic temperature.",
   "remark_raw": "This is equivalent to setting \\hyperlink{SMEARING}{\\texttt{SMEARING}} (0.001 Ha = 315.775 Kelvin).",
   "category": "system"
  },
  "ELEC_TEMP_TYPE": {
   "symbol": "ELEC_TEMP_TYPE",
   "label": "ELEC_TEMP_TYPE",
   "type": "string",
   "default": "gaussian",
   "unit": "No unit",
   "example": "ELEC_TEMP_TYPE: fd",
   "description": "Function used for the smearing (electronic temperature). Options are: fermi-dirac (or fd), gaussian.",
   "remark": "Use ELEC_TEMP or SMEARING to set smearing value.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{gaussian}",
   "description_raw": "Function used for the smearing (electronic temperature). Options are: \\texttt{fermi-dirac} (or \\texttt{fd}), \\texttt{gaussian}.",
   "remark_raw": "Use \\hyperlink{ELEC_TEMP}{\\texttt{ELEC\\_TEMP}} or \\hyperlink{SMEARING}{\\texttt{SMEARING}} to set smearing value.",
   "category": "system"
  },
  "EXCHANGE_CORRELATION": {
   "symbol": "EXCHANGE_CORRELATION",
   "label": "EXCHANGE_CORRELATION",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "EXCHANGE_CORRELATION: LDA_PW",
   "description": "Choice of exchange-correlation functional. Options are LDA_PW (Perdew-Wang LDA), LDA_PZ (Purdew-Zunger LDA), \nGGA_PBE (PBE GGA), GGA_RPBE (revised PBE GGA), and GGA_PBEsol (PBE GGA revised for solids), \nPBE0, HF (Hartree-Fock), HSE,\nvdWDF1 (van der Waals Density Functional developed by Dion et al.), vdWDF2 (vdW Density Functional modified by Lee et al), SCAN (SCAN metaGGA), RSCAN (rSCAN metaGGA), and R2SCAN (r2SCAN metaGGA).",
   "remark": "For spin-polarized calculation (SPIN_TYP = 1), LDA_PZ is not available.\nCurrently SCAN, RSCAN and R2SCAN does not support nonlinear core correction pseudopotential.",
   "allow_bool_input": false,
   "default_remark": "No Default",
   "description_raw": "Choice of exchange-correlation functional. Options are \\texttt{LDA\\_PW} (Perdew-Wang LDA), \\texttt{LDA\\_PZ} (Purdew-Zunger LDA), \n\\texttt{GGA\\_PBE} (PBE GGA), \\texttt{GGA\\_RPBE} (revised PBE GGA), and \\texttt{GGA\\_PBEsol} (PBE GGA revised for solids), \n\\texttt{PBE0}, \\texttt{HF} (Hartree-Fock), \\texttt{HSE},\n\\texttt{vdWDF1} (van der Waals Density Functional developed by Dion et al.), \\texttt{vdWDF2} (vdW Density Functional modified by Lee et al), \\texttt{SCAN} (SCAN metaGGA), \\texttt{RSCAN} (rSCAN metaGGA), and \\texttt{R2SCAN} (r2SCAN metaGGA).",
   "remark_raw": "For spin-polarized calculation (\\hyperlink{SPIN_TYP}{\\texttt{SPIN\\_TYP}} = 1), \\texttt{LDA\\_PZ} is not available.\n\nCurrently SCAN, RSCAN and R2SCAN does not support nonlinear core correction pseudopotential.",
   "category": "system"
  },
  "EXX_ACC": {
   "symbol": "EXX_ACC",
   "label": "EXX_ACC",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "EXX_ACC: 0",
   "description": "Use accelerated method for exact exchange. For low-T, use ACE operator to accelarte the hybrid calculation, while in high-T, use the local projection method.",
   "remark": "Without acceleration, the hybrid functional will be extremely slow.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Use accelerated method for exact exchange. For low-T, use ACE operator to accelarte the hybrid calculation, while in high-T, use the local projection method.",
   "remark_raw": "Without acceleration, the hybrid functional will be extremely slow.",
   "category": "scf"
  },
  "EXX_ACE_VALENCE_STATES": {
   "symbol": "EXX_ACE_VALENCE_STATES",
   "label": "EXX_ACE_VALENCE_STATES",
   "type": "integer",
   "default": 3,
   "unit": "No unit",
   "example": "EXX_ACE_VALENCE_STATES: 1",
   "description": "Control of number of unoccupied states used to construct ACE operator. Only effective on low-T calculation.",
   "remark": "Only active when using hybrid functionals with ACE operator.",
   "allow_bool_input": false,
   "default_remark": "3",
   "description_raw": "Control of number of unoccupied states used to construct ACE operator. Only effective on low-T calculation.",
   "remark_raw": "Only active when using hybrid functionals with ACE operator.",
   "category": "scf"
  },
  "EXX_DIVERGENCE": {
   "symbol": "EXX_DIVERGENCE",
   "label": "EXX_DIVERGENCE",
   "type": "string",
   "default": "SPHERICAL",
   "unit": "No unit",
   "example": "EXX_DIVERGENCE: AUXILIARY",
   "description": "Treatment of divergence in exact exchange. Options are SPHERICAL (spherical truncation), \n    AUXILIARY (auxiliary function method) and ERFC (erfc screening). Only effective on low-T calculation.",
   "remark": "For systems with cube-like geometry, both methods converge fast. For slab and wire, auxiliary function method is a better option. \n    ERFC screening is the default option for HSE in bulk and molecule simulation.",
   "allow_bool_input": false,
   "default_remark": "SPHERICAL",
   "description_raw": "Treatment of divergence in exact exchange. Options are \\texttt{SPHERICAL} (spherical truncation), \n    \\texttt{AUXILIARY} (auxiliary function method) and \\texttt{ERFC} (erfc screening). Only effective on low-T calculation.",
   "remark_raw": "For systems with cube-like geometry, both methods converge fast. For slab and wire, auxiliary function method is a better option. \n    ERFC screening is the default option for HSE in bulk and molecule simulation.",
   "category": "scf"
  },
  "EXX_DOWNSAMPLING": {
   "symbol": "EXX_DOWNSAMPLING",
   "label": "EXX_DOWNSAMPLING",
   "type": "integer array",
   "default": [
    1,
    1,
    1
   ],
   "unit": "No unit",
   "example": "EXX_DOWNSAMPLING: 1 2 3",
   "description": "Down-sampling of k-points grids. There should be 3 nonnegative integers. 0 means using 0 k-point in that direction, \n    requiring 0 is one of the k-point after time-reversal symmetry in that direction. \n    Positive value should be a factor of the number of grid points in that direction. Only effective on low-T calculation.",
   "remark": "One could only do downsampling on directions of periodic boundary condition.",
   "allow_bool_input": false,
   "default_remark": "1 1 1",
   "description_raw": "Down-sampling of k-points grids. There should be 3 nonnegative integers. 0 means using 0 k-point in that direction, \n    requiring 0 is one of the k-point after time-reversal symmetry in that direction. \n    Positive value should be a factor of the number of grid points in that direction. Only effective on low-T calculation.",
   "remark_raw": "One could only do downsampling on directions of periodic boundary condition.",
   "category": "scf"
  },
  "EXX_FRAC": {
   "symbol": "EXX_FRAC",
   "label": "EXX_FRAC",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "EXX_FRAC: 0.3",
   "description": "Fraction of exact exchange in hybrid functional, e.g. PBE0 and HSE, while the fraction of PBE is 1-EXX_FRAC",
   "allow_bool_input": false,
   "default_remark": "0.25 for PBE0 and HSE",
   "description_raw": "Fraction of exact exchange in hybrid functional, e.g. PBE0 and HSE, while the fraction of PBE is 1-\\texttt{EXX\\_FRAC}",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "EXX_MEM": {
   "symbol": "EXX_MEM",
   "label": "EXX_MEM",
   "type": "integer",
   "default": 20,
   "unit": "No unit",
   "example": "EXX_MEM: 0",
   "description": "Number of Poisson's equations to be solved in each process at a time when creating exact exchange operator or ACE operator. Typically, when EXX_MEM is larger than 20, the speed of code is barely affected. When it is 0, all Poisson's equations are solved together and it hits the fastest speed but largest memory requirement. Only effective on low-T calculation.",
   "allow_bool_input": false,
   "default_remark": "20",
   "description_raw": "Number of Poisson's equations to be solved in each process at a time when creating exact exchange operator or ACE operator. Typically, when \\texttt{EXX\\_MEM} is larger than 20, the speed of code is barely affected. When it is 0, all Poisson's equations are solved together and it hits the fastest speed but largest memory requirement. Only effective on low-T calculation.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "EXX_METHOD": {
   "symbol": "EXX_METHOD",
   "label": "EXX_METHOD",
   "type": "string",
   "default": "KRON",
   "unit": "No unit",
   "example": "EXX_METHOD: FFT",
   "description": "Method to solve the Poisson's equations in exact exchange. Options include KRON (Laplacian using kronecker product) and FFFT (FFT to solve in Fourier space). Now, KRON is only available for orthogonal periodic cell on gamma point and dirichlet molecule using PBE0. Generally, KRON way is faster than FFT, while FFT is faster on certain type of grid with even number of grid points each direction etc.",
   "allow_bool_input": false,
   "default_remark": "KRON",
   "description_raw": "Method to solve the Poisson's equations in exact exchange. Options include KRON (Laplacian using kronecker product) and FFFT (FFT to solve in Fourier space). Now, KRON is only available for orthogonal periodic cell on gamma point and dirichlet molecule using PBE0. Generally, KRON way is faster than FFT, while FFT is faster on certain type of grid with even number of grid points each direction etc.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "EXX_RANGE_FOCK": {
   "symbol": "EXX_RANGE_FOCK",
   "label": "EXX_RANGE_FOCK",
   "type": "double",
   "default": 0.1587,
   "unit": "1/Bohr",
   "example": "EXX_RANGE_FOCK: 0.106",
   "description": "Short range screen parameter of hartree-fock operator in HSE functional.",
   "remark": "Default is using VASP's HSE03 value. Different code has different parameters. Be careful with the results.",
   "allow_bool_input": false,
   "default_remark": "0.1587",
   "description_raw": "Short range screen parameter of hartree-fock operator in HSE functional.",
   "remark_raw": "Default is using VASP's HSE03 value. Different code has different parameters. Be careful with the results.",
   "category": "system"
  },
  "EXX_RANGE_PBE": {
   "symbol": "EXX_RANGE_PBE",
   "label": "EXX_RANGE_PBE",
   "type": "double",
   "default": 0.1587,
   "unit": "1/Bohr",
   "example": "EXX_RANGE_PBE: 0.106",
   "description": "Short range screen parameter of PBE in HSE functional.",
   "remark": "Default is using VASP's HSE03 value. Different code has different parameters. Be careful with the results.",
   "allow_bool_input": false,
   "default_remark": "0.1587",
   "description_raw": "Short range screen parameter of PBE in HSE functional.",
   "remark_raw": "Default is using VASP's HSE03 value. Different code has different parameters. Be careful with the results.",
   "category": "system"
  },
  "FD_GRID": {
   "symbol": "FD_GRID",
   "label": "FD_GRID",
   "type": "integer array",
   "default": null,
   "unit": "No unit",
   "example": "FD_GRID: 26 26 30",
   "description": "A set of three whitespace delimited values specifying the number of finite-difference intervals in the lattice vector (LATVEC) directions, respectively.",
   "remark": "The convergence of results with respect to spatial discretization needs to be verified. ECUT, MESH_SPACING, FD_GRID cannot be specified simultaneously.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "A set of three whitespace delimited values specifying the number of finite-difference intervals in the lattice vector (\\hyperlink{LATVEC}{\\texttt{LATVEC}}) directions, respectively.",
   "remark_raw": "The convergence of results with respect to spatial discretization needs to be verified. \\hyperlink{ECUT}{\\texttt{ECUT}}, \\hyperlink{MESH_SPACING}{\\texttt{MESH\\_SPACING}}, \\hyperlink{FD_GRID}{\\texttt{FD\\_GRID}} cannot be specified simultaneously.",
   "category": "system"
  },
  "FD_ORDER": {
   "symbol": "FD_ORDER",
   "label": "FD_ORDER",
   "type": "integer",
   "default": 12,
   "unit": "No unit",
   "example": "FD_ORDER: 12",
   "description": "Order of the finite-difference approximation.",
   "remark": "Restricted to even integers since central finite-differences are employed. The default value of 12 has been found to be an efficient choice for most systems.",
   "allow_bool_input": false,
   "default_remark": "12",
   "description_raw": "Order of the finite-difference approximation.",
   "remark_raw": "Restricted to even integers since central finite-differences are employed. The default value of 12 has been found to be an efficient choice for most systems.",
   "category": "system"
  },
  "FIRE_DT": {
   "symbol": "FIRE_DT",
   "label": "FIRE_DT",
   "type": "double",
   "default": 1.0,
   "unit": "Femto second",
   "example": "FIRE_DT: 0.1",
   "description": "Time step used in FIRE (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "Time step used in FIRE (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "FIRE_MASS": {
   "symbol": "FIRE_MASS",
   "label": "FIRE_MASS",
   "type": "double",
   "default": 1.0,
   "unit": "Atomic mass unit",
   "example": "FIRE_MASS: 2.5",
   "description": "Pseudomass used in FIRE (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "1.0",
   "description_raw": "Pseudomass used in FIRE (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "FIRE_MAXMOV": {
   "symbol": "FIRE_MAXMOV",
   "label": "FIRE_MAXMOV",
   "type": "double",
   "default": 0.2,
   "unit": "Bohr",
   "example": "FIRE_MAXMOV: 1.0",
   "description": "Maximum movement for any atom in FIRE (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "0.2",
   "description_raw": "Maximum movement for any atom in FIRE (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "FIX_RAND": {
   "symbol": "FIX_RAND",
   "label": "FIX_RAND",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "FIX_RAND: 1",
   "description": "Flag to fix the random seeds for setting initial guesses. Once set to 1, the random seeds will be fixed for different runs and for different numbers of processors. This option will make sure the answers will be exactly the same (up to machine precision) when SPARC is executed with different numbers of processors.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to fix the random seeds for setting initial guesses. Once set to $1$, the random seeds will be fixed for different runs and for different numbers of processors. This option will make sure the answers will be exactly the same (up to machine precision) when SPARC is executed with different numbers of processors.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "INPUT_DENS_FILE": {
   "symbol": "INPUT_DENS_FILE",
   "label": "INPUT_DENS_FILE",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "INPUT_DENS_FILE: Si.dens Si.densUp Si.densDwn",
   "description": "The name of the input density file(s) in cube format.",
   "remark": "For spin-unpolarized systems, only the total density file is required. For spin-polarized systems, three density files are required, which are the total electron density, spin-up density, and spin-down density, respectively.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The name of the input density file(s) in cube format.",
   "remark_raw": "For spin-unpolarized systems, only the total density file is required. For spin-polarized systems, three density files are required, which are the total electron density, spin-up density, and spin-down density, respectively.",
   "category": "band structure"
  },
  "ION_TEMP": {
   "symbol": "ION_TEMP",
   "label": "ION_TEMP",
   "type": "double",
   "default": null,
   "unit": "Kelvin",
   "example": "ION_TEMP: 315",
   "description": "Starting ionic temperature in QMD, used to generate initial velocity distribution.",
   "remark": "Must be specified if MD_FLAG is set to 1. It is also the target temperature in MD_METHOD NPT_NH and NPT_NP.",
   "allow_bool_input": false,
   "default_remark": "No Default",
   "description_raw": "Starting ionic temperature in QMD, used to generate initial velocity distribution.",
   "remark_raw": "Must be specified if \\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} is set to $1$. It is also the target temperature in \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} NPT\\_NH and NPT\\_NP.",
   "category": "qmd"
  },
  "ION_TEMP_END": {
   "symbol": "ION_TEMP_END",
   "label": "ION_TEMP_END",
   "type": "double",
   "default": null,
   "unit": "Kelvin",
   "example": "ION_TEMP_END: 100",
   "description": "Specifies the final temperature of the thermostat. Thermostat temperature is varied linearly from ION_TEMP to ION_TEMP_END with respect to time.",
   "remark": "Available for NVT_NH quantum molecular dynamics only. Not supported in NPT_NH and NPT_NP.",
   "allow_bool_input": false,
   "default_remark": "ION\\_TEMP",
   "description_raw": "Specifies the final temperature of the thermostat. Thermostat temperature is varied linearly from \\hyperlink{ION_TEMP}{\\texttt{ION\\_TEMP}} to \\hyperlink{ION_TEMP_END}{\\texttt{ION\\_TEMP\\_END}} with respect to time.",
   "remark_raw": "Available for NVT\\_NH quantum molecular dynamics only. Not supported in NPT\\_NH and NPT\\_NP.",
   "category": "qmd"
  },
  "ION_VEL_DSTR": {
   "symbol": "ION_VEL_DSTR",
   "label": "ION_VEL_DSTR",
   "type": "integer",
   "default": 2,
   "unit": "No unit",
   "example": "ION_VEL_DSTR: 1",
   "description": "Specifies the type of distribution for the initial velocity of atoms based on their initial temperature. Choose 1 for uniform velocity distribution and 2 for Maxwell-Boltzmann distribution.",
   "remark": "Currently, the code supports only two options for the variable.",
   "allow_bool_input": false,
   "default_remark": "2",
   "description_raw": "Specifies the type of distribution for the initial velocity of atoms based on their initial temperature. Choose $1$ for uniform velocity distribution and $2$ for Maxwell-Boltzmann distribution.",
   "remark_raw": "Currently, the code supports only two options for the variable.",
   "category": "qmd"
  },
  "ION_VEL_DSTR_RAND": {
   "symbol": "ION_VEL_DSTR_RAND",
   "label": "ION_VEL_DSTR_RAND",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "ION_VEL_DSTR_RAND: 1",
   "description": "Flag to reseed the initial velocities of atoms in a QMD simulation. Set this flag to 1 to shuffle (change the random seed for) the initial velocities for different runs. Set this flag to 0 to maintain the same initial velocities.",
   "remark": "This option is convenient for parallel statistics calculations.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to reseed the initial velocities of atoms in a QMD simulation. Set this flag to $1$ to shuffle (change the random seed for) the initial velocities for different runs. Set this flag to $0$ to maintain the same initial velocities.",
   "remark_raw": "This option is convenient for parallel statistics calculations.",
   "category": "qmd"
  },
  "KPOINT_GRID": {
   "symbol": "KPOINT_GRID",
   "label": "KPOINT_GRID",
   "type": "integer array",
   "default": [
    1,
    1,
    1
   ],
   "unit": "No unit",
   "example": "KPOINT_GRID: 2 3 4",
   "description": "Number of k-points in each direction of the Monkhorst-Pack grid for Brillouin zone integration.",
   "remark": "Time-reversal symmetry is assumed to hold.",
   "allow_bool_input": false,
   "default_remark": "1 1 1",
   "description_raw": "Number of k-points in each direction of the Monkhorst-Pack grid for Brillouin zone integration.",
   "remark_raw": "Time-reversal symmetry is assumed to hold.",
   "category": "system"
  },
  "KPOINT_SHIFT": {
   "symbol": "KPOINT_SHIFT",
   "label": "KPOINT_SHIFT",
   "type": "double array",
   "default": null,
   "unit": "No unit",
   "example": "KPOINT_SHIFT: 0.5 0.5 0.5",
   "description": "Shift of k-points with respect to k-point grid containing \\Gamma-point.",
   "remark": "The shift is in reduced coordinates.",
   "allow_bool_input": false,
   "default_remark": "0.0 for odd k-point mesh\\\\\n 0.5 for even k-point mesh",
   "description_raw": "Shift of k-points with respect to k-point grid containing $\\Gamma$-point.",
   "remark_raw": "The shift is in reduced coordinates.",
   "category": "system"
  },
  "KPT_PATHS": {
   "symbol": "KPT_PATHS",
   "label": "KPT_PATHS",
   "type": "double array",
   "default": null,
   "unit": "No unit",
   "example": "KPT_PATHS: 2\n0.0 0.0 0.0 \n# Gamma\n0.5 0.5 0.5 \n# A\n0.5 0.5 0.5 \n# A\n0.5 0.5 0.0 \n# M",
   "description": "The k-point paths (high-symmetry lines) for band structure calculations.  It starts with the total number of high-symmetry lines, followed by fractional coordinates indicating the start and end points of each line.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The k-point paths (high-symmetry lines) for band structure calculations.  It starts with the total number of high-symmetry lines, followed by fractional coordinates indicating the start and end points of each line.",
   "remark_raw": "",
   "remark": "",
   "category": "band structure"
  },
  "KPT_PER_LINE": {
   "symbol": "KPT_PER_LINE",
   "label": "KPT_PER_LINE",
   "type": "integer",
   "default": 10,
   "unit": "No unit",
   "example": "KPT_PER_LINE: 15",
   "description": "The number of k-points on each high-symmetry line.",
   "remark": "This value accounts for both endpoints of the high-symmetry line.",
   "allow_bool_input": false,
   "default_remark": "10",
   "description_raw": "The number of k-points on each high-symmetry line.",
   "remark_raw": "This value accounts for both endpoints of the high-symmetry line.",
   "category": "band structure"
  },
  "LATVEC": {
   "symbol": "LATVEC",
   "label": "LATVEC",
   "type": "double array",
   "default": [
    [
     1.0,
     0.0,
     0.0
    ],
    [
     0.0,
     1.0,
     0.0
    ],
    [
     0.0,
     0.0,
     1.0
    ]
   ],
   "unit": "No unit",
   "example": "LATVEC: 0.5 0.5 0.0\n0.0 0.5 0.5\n0.5 0.0 0.5",
   "description": "A set of three vectors in row major order specifying the lattice vectors of the simulation domain (CELL).",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "1.0 0.0 0.0\\\\\n0.0 1.0 0.0\\\\\n0.0 0.0 1.0\\\\",
   "description_raw": "A set of three vectors in row major order specifying the lattice vectors of the simulation domain (\\hyperlink{CELL}{\\texttt{CELL}}).",
   "remark_raw": "%Lattice vectors need not be unit vectors.\n%",
   "category": "system"
  },
  "LATVEC_SCALE": {
   "symbol": "LATVEC_SCALE",
   "label": "LATVEC_SCALE",
   "type": "double array",
   "default": null,
   "unit": "Bohr",
   "example": "LATVEC_SCALE: 10.20 11.21 7.58",
   "description": "A set of three whitespace delimited values specifying the scaling factors in the lattice vectors (LATVEC), respectively.",
   "remark": "The difference between LATVEC_SCALE and CELL is that CELL treats the lattice vectors as unit vectors, whereas LATVEC_SCALE scales the lattice vectors directly as specified by the user. LATVEC_SCALE and CELL cannot be specified simultaneously.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "A set of three whitespace delimited values specifying the scaling factors in the lattice vectors (\\hyperlink{LATVEC}{\\texttt{LATVEC}}), respectively.",
   "remark_raw": "The difference between \\hyperlink{LATVEC_SCALE}{\\texttt{LATVEC\\_SCALE}} and \\hyperlink{CELL}{\\texttt{CELL}} is that \\hyperlink{CELL}{\\texttt{CELL}} treats the lattice vectors as unit vectors, whereas \\hyperlink{LATVEC_SCALE}{\\texttt{LATVEC\\_SCALE}} scales the lattice vectors directly as specified by the user. \\hyperlink{LATVEC_SCALE}{\\texttt{LATVEC\\_SCALE}} and \\hyperlink{CELL}{\\texttt{CELL}} cannot be specified simultaneously.",
   "category": "system"
  },
  "L_AUTOSCALE": {
   "symbol": "L_AUTOSCALE",
   "label": "L_AUTOSCALE",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "L_AUTOSCALE: 0",
   "description": "Flag for automatically determining the inverse curvature that is used to determine the direction for next iteration in LBFGS (RELAX_METHOD).",
   "remark": "Default works well in most cases.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for automatically determining the inverse curvature that is used to determine the direction for next iteration in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default works well in most cases.",
   "category": "structural relaxation"
  },
  "L_FINIT_STP": {
   "symbol": "L_FINIT_STP",
   "label": "L_FINIT_STP",
   "type": "double",
   "default": 0.005,
   "unit": "Bohr",
   "example": "L_FINIT_STP: 0.01",
   "description": "Step length for line optimizer in LBFGS (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "5e-3",
   "description_raw": "Step length for line optimizer in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "L_HISTORY": {
   "symbol": "L_HISTORY",
   "label": "L_HISTORY",
   "type": "integer",
   "default": 20,
   "unit": "No unit",
   "example": "L_HISTORY: 15",
   "description": "Size of history in LBFGS (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "20",
   "description_raw": "Size of history in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "L_ICURV": {
   "symbol": "L_ICURV",
   "label": "L_ICURV",
   "type": "double",
   "default": 1.0,
   "unit": "No unit",
   "example": "L_ICURV: 0.1",
   "description": "Initial inverse curvature, used to construct the inverse Hessian matrix in LBFGS (RELAX_METHOD).",
   "remark": "Needed only if  L_AUTOSCALE is 0. Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "1.0",
   "description_raw": "Initial inverse curvature, used to construct the inverse Hessian matrix in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Needed only if  \\hyperlink{L_AUTOSCALE}{\\texttt{L\\_AUTOSCALE}} is $0$. Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "L_LINEOPT": {
   "symbol": "L_LINEOPT",
   "label": "L_LINEOPT",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "L_LINEOPT: 0",
   "description": "Flag for atomic force based line minimization in LBFGS (RELAX_METHOD).",
   "remark": "Required only if L_AUTOSCALE is 0.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for atomic force based line minimization in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Required only if \\hyperlink{L_AUTOSCALE}{\\texttt{L\\_AUTOSCALE}} is $0$.",
   "category": "structural relaxation"
  },
  "L_MAXMOV": {
   "symbol": "L_MAXMOV",
   "label": "L_MAXMOV",
   "type": "double",
   "default": 0.2,
   "unit": "Bohr",
   "example": "L_MAXMOV: 1.0",
   "description": "The maximum allowed step size in LBFGS (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "0.2",
   "description_raw": "The maximum allowed step size in LBFGS (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "MAXIT_FOCK": {
   "symbol": "MAXIT_FOCK",
   "label": "MAXIT_FOCK",
   "type": "integer",
   "default": 20,
   "unit": "No unit",
   "example": "MAXIT_FOCK: 50",
   "description": "The maximum number of iterations for Hartree-Fock outer loop.",
   "remark": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "allow_bool_input": false,
   "default_remark": "20",
   "description_raw": "The maximum number of iterations for Hartree-Fock outer loop.",
   "remark_raw": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "category": "scf"
  },
  "MAXIT_POISSON": {
   "symbol": "MAXIT_POISSON",
   "label": "MAXIT_POISSON",
   "type": "integer",
   "default": 3000,
   "unit": "No unit",
   "example": "MAXIT_POISSON: 1000",
   "description": "The maximum number of iterations for solving the Poisson equation using an iterative linear solver.",
   "allow_bool_input": false,
   "default_remark": "$3000$",
   "description_raw": "The maximum number of iterations for solving the Poisson equation using an iterative linear solver.",
   "remark_raw": "",
   "remark": "",
   "category": "electrostatics"
  },
  "MAXIT_SCF": {
   "symbol": "{MAXIT_SCF",
   "label": "MAXIT_SCF",
   "type": "integer",
   "default": 100,
   "unit": "No unit",
   "example": "MAXIT_SCF: 50",
   "description": "Maximum number of SCF iterations.",
   "remark": "Larger values than the default of 100 may be required for highly inhomogeneous systems, particularly when small values of SMEARING/ELEC_TEMP are chosen.",
   "allow_bool_input": false,
   "default_remark": "100",
   "description_raw": "Maximum number of SCF iterations.",
   "remark_raw": "Larger values than the default of 100 may be required for highly inhomogeneous systems, particularly when small values of \\hyperlink{SMEARING}{\\texttt{SMEARING}}/\\hyperlink{ELEC_TEMP}{\\texttt{ELEC\\_TEMP}} are chosen.",
   "category": "scf"
  },
  "MD_FLAG": {
   "symbol": "MD_FLAG",
   "label": "MD_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "MD_FLAG: 1",
   "description": "QMD simulations are performed if the flag is set to 1.",
   "remark": "MD_FLAG and RELAX_FLAG both cannot be set to a value greater than 0.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "QMD simulations are performed if the flag is set to 1.",
   "remark_raw": "\\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} and \\hyperlink{RELAX_FLAG}{\\texttt{RELAX\\_FLAG}} both cannot be set to a value greater than 0.",
   "category": "qmd"
  },
  "MD_METHOD": {
   "symbol": "MD_METHOD",
   "label": "MD_METHOD",
   "type": "string",
   "default": "NVT_NH",
   "unit": "No unit",
   "example": "MD_METHOD: NVE",
   "description": "Type of QMD to be performed. Currently, NVE (microcanonical ensemble), NVT_NH (canonical ensemble with Nose-Hoover thermostat), NVK_G (isokinetic ensemble with Gaussian thermostat), NPT_NH (isothermal-isobaric ensemble with Nose-Hoover thermostat) and NPT_NP (isothermal-isobaric ensemble with Nose-Poincare thermostat) are supported.",
   "allow_bool_input": false,
   "default_remark": "NVT\\_NH",
   "description_raw": "Type of QMD to be performed. Currently, NVE (microcanonical ensemble), NVT\\_NH (canonical ensemble with Nose-Hoover thermostat), NVK\\_G (isokinetic ensemble with Gaussian thermostat), NPT\\_NH (isothermal-isobaric ensemble with Nose-Hoover thermostat) and NPT\\_NP (isothermal-isobaric ensemble with Nose-Poincare thermostat) are supported.",
   "remark_raw": "",
   "remark": "",
   "category": "qmd"
  },
  "MD_NSTEP": {
   "symbol": "MD_NSTEP",
   "label": "MD_NSTEP",
   "type": "integer",
   "default": 10000000,
   "unit": "No unit",
   "example": "MD_NSTEP: 100",
   "description": "Specifies the number of QMD steps.",
   "remark": "If MD_NSTEP = N, the QMD runs from 0 to (N-1) x MD_TIMESTEP fs.",
   "allow_bool_input": false,
   "default_remark": "1e7",
   "description_raw": "Specifies the number of QMD steps.",
   "remark_raw": "If MD\\_NSTEP $= N$, the QMD runs from $0$ to $(N-1) \\times$ \\hyperlink{MD_TIMESTEP}{\\texttt{MD\\_TIMESTEP}} fs.",
   "category": "qmd"
  },
  "MD_TIMESTEP": {
   "symbol": "MD_TIMESTEP",
   "label": "MD_TIMESTEP",
   "type": "double",
   "default": 1.0,
   "unit": "Femtosecond",
   "example": "MD_TIMESTEP: 0.1",
   "description": "QMD time step.",
   "remark": "Total QMD time is given by:  MD_TIMESTEP x (MD_NSTEP - 1).",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "QMD time step.",
   "remark_raw": "Total QMD time is given by:  \\hyperlink{MD_TIMESTEP}{\\texttt{MD\\_TIMESTEP}} $\\times$ (\\hyperlink{MD_NSTEP}{\\texttt{MD\\_NSTEP}} - 1).",
   "category": "qmd"
  },
  "MESH_SPACING": {
   "symbol": "MESH_SPACING",
   "label": "MESH_SPACING",
   "type": "double",
   "default": null,
   "unit": "Bohr",
   "example": "MESH_SPACING: 0.4",
   "description": "Mesh spacing of the finite-difference grid.",
   "remark": "The exact mesh-size will be determined by the size of the domain.  MESH_SPACING, FD_GRID, ECUT cannot be specified simultaneously.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Mesh spacing of the finite-difference grid.",
   "remark_raw": "The exact mesh-size will be determined by the size of the domain.  \\hyperlink{MESH_SPACING}{\\texttt{MESH\\_SPACING}}, \\hyperlink{FD_GRID}{\\texttt{FD\\_GRID}}, \\hyperlink{ECUT}{\\texttt{ECUT}} cannot be specified simultaneously.",
   "category": "system"
  },
  "MINIT_FOCK": {
   "symbol": "MINIT_FOCK",
   "label": "MINIT_FOCK",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "MINIT_FOCK: 3",
   "description": "The minimum number of iterations for Hartree-Fock outer loop.",
   "remark": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "The minimum number of iterations for Hartree-Fock outer loop.",
   "remark_raw": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "category": "scf"
  },
  "MINIT_SCF": {
   "symbol": "{MINIT_SCF",
   "label": "MINIT_SCF",
   "type": "integer",
   "default": 3,
   "unit": "No unit",
   "example": "MAXIT_SCF: 5",
   "description": "Minimum number of SCF iterations.",
   "allow_bool_input": false,
   "default_remark": "3",
   "description_raw": "Minimum number of SCF iterations.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "MIXING_HISTORY": {
   "symbol": "MIXING_HISTORY",
   "label": "MIXING_HISTORY",
   "type": "integer",
   "default": 7,
   "unit": "No unit",
   "example": "MIXING_HISTORY: 40",
   "description": "The mixing history used in Pulay mixing.",
   "remark": "Too small values of MIXING_HISTORY can result in poor SCF convergence.",
   "allow_bool_input": false,
   "default_remark": "7",
   "description_raw": "The mixing history used in Pulay mixing.",
   "remark_raw": "Too small values of \\hyperlink{MIXING_HISTORY}{\\texttt{MIXING\\_HISTORY}} can result in poor SCF convergence.",
   "category": "scf"
  },
  "MIXING_PARAMETER": {
   "symbol": "MIXING_PARAMETER",
   "label": "MIXING_PARAMETER",
   "type": "double",
   "default": 0.3,
   "unit": "No unit",
   "example": "MIXING_PARAMETER: 0.1",
   "description": "The value of the relaxation parameter used in Pulay/simple mixing.",
   "remark": "Values larger than the default value of 0.3 can be used for insulating systems, whereas smaller values are generally required for metallic  systems, particularly at small values of SMEARING or ELEC_TEMP.",
   "allow_bool_input": false,
   "default_remark": "0.3",
   "description_raw": "The value of the relaxation parameter used in Pulay/simple mixing.",
   "remark_raw": "Values larger than the default value of 0.3 can be used for insulating systems, whereas smaller values are generally required for metallic  systems, particularly at small values of \\hyperlink{SMEARING}{\\texttt{SMEARING}} or \\hyperlink{ELEC_TEMP}{\\texttt{ELEC\\_TEMP}}.",
   "category": "scf"
  },
  "MIXING_PARAMETER_MAG": {
   "symbol": "MIXING_PARAMETER_MAG",
   "label": "MIXING_PARAMETER_MAG",
   "type": "double",
   "default": "auto",
   "unit": "No unit",
   "example": "MIXING_PARAMETER_MAG: 4.0",
   "description": "The mixing parameter for the magnetization density in Pulay mixing for spin-polarized calculations.",
   "remark": "For spin-polarized calculations, when SCF has difficulty to converge, increasing the mixing parameter to magnetization density might help. For example, setting it to 4.0, while turning off the preconditioner applied to the magnetization density (by setting MIXING_PRECOND_MAG to `none') is a good choice.",
   "allow_bool_input": false,
   "default_remark": "Automatically set to the same as \\hyperlink{MIXING_PARAMETER}{\\texttt{MIXING\\_PARAMETER}}.",
   "description_raw": "The mixing parameter for the magnetization density in Pulay mixing for spin-polarized calculations.",
   "remark_raw": "For spin-polarized calculations, when SCF has difficulty to converge, increasing the mixing parameter to magnetization density might help. For example, setting it to 4.0, while turning off the preconditioner applied to the magnetization density (by setting \\hyperlink{MIXING_PRECOND_MAG}{\\texttt{MIXING\\_PRECOND\\_MAG}} to `\\texttt{none}') is a good choice.",
   "category": "scf"
  },
  "MIXING_PARAMETER_SIMPLE": {
   "symbol": "MIXING_PARAMETER_SIMPLE",
   "label": "MIXING_PARAMETER_SIMPLE",
   "type": "double",
   "default": "auto",
   "unit": "No unit",
   "example": "MIXING_PARAMETER_SIMPLE: 0.1",
   "description": "The value of the relaxation parameter used in the simple mixing step in the periodic Pulay scheme.",
   "allow_bool_input": false,
   "default_remark": "Automatically set to the same as \\hyperlink{MIXING_PARAMETER}{\\texttt{MIXING\\_PARAMETER}}",
   "description_raw": "The value of the relaxation parameter used in the simple mixing step in the periodic Pulay scheme.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "MIXING_PARAMETER_SIMPLE_MAG": {
   "symbol": "MIXING_PARAMETER_SIMPLE_MAG",
   "label": "MIXING_PARAMETER_SIMPLE_MAG",
   "type": "double",
   "default": "auto",
   "unit": "No unit",
   "example": "MIXING_PARAMETER_SIMPLE_MAG: 4.0",
   "description": "The value of the relaxation parameter for the magnetization density used in the simple mixing step in the periodic Pulay scheme for spin-polarized calculations.",
   "allow_bool_input": false,
   "default_remark": "Automatically set to the same as \\hyperlink{MIXING_PARAMETER_MAG}{\\texttt{MIXING\\_PARAMETER\\_MAG}}",
   "description_raw": "The value of the relaxation parameter for the magnetization density used in the simple mixing step in the periodic Pulay scheme for spin-polarized calculations.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "MIXING_PRECOND": {
   "symbol": "MIXING_PRECOND",
   "label": "MIXING_PRECOND",
   "type": "string",
   "default": "kerker",
   "unit": "No unit",
   "example": "MIXING_PRECOND: none",
   "description": "This specifies the preconditioner used in the SCF iteration. Available options are: none, kerker.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{kerker}",
   "description_raw": "This specifies the preconditioner used in the SCF iteration. Available options are: \\texttt{none}, \\texttt{kerker}.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "MIXING_PRECOND_MAG": {
   "symbol": "MIXING_PRECOND_MAG",
   "label": "MIXING_PRECOND_MAG",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "MIXING_PRECOND_MAG: kerker",
   "description": "This specifies the preconditioner used for the magnetization density in the SCF iteration for spin-polarized calculations. Available options are: none, kerker.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{none}",
   "description_raw": "This specifies the preconditioner used for the magnetization density in the SCF iteration for spin-polarized calculations. Available options are: \\texttt{none}, \\texttt{kerker}.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "MIXING_VARIABLE": {
   "symbol": "MIXING_VARIABLE",
   "label": "MIXING_VARIABLE",
   "type": "string",
   "default": "density",
   "unit": "No unit",
   "example": "MIXING_VARIABLE: potential",
   "description": "This specifies whether potential or density mixing is performed in the SCF iteration. Available options are: potential and density.",
   "allow_bool_input": false,
   "default_remark": "\\texttt{density}",
   "description_raw": "This specifies whether potential or density mixing is performed in the SCF iteration. Available options are: \\texttt{potential} and \\texttt{density}.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "NLCG_SIGMA": {
   "symbol": "NLCG_SIGMA",
   "label": "NLCG_SIGMA",
   "type": "double",
   "default": 0.5,
   "unit": "No unit",
   "example": "NLCG_SIGMA: 1",
   "description": "Parameter in the secant method used to control the step length in NLCG (RELAX_METHOD).",
   "remark": "Default value works well in most cases.",
   "allow_bool_input": false,
   "default_remark": "0.5",
   "description_raw": "Parameter in the secant method used to control the step length in NLCG (\\hyperlink{RELAX_METHOD}{\\texttt{RELAX\\_METHOD}}).",
   "remark_raw": "Default value works well in most cases.",
   "category": "structural relaxation"
  },
  "NPT_NH_BMASS": {
   "symbol": "NPT_NH_BMASS",
   "label": "NPT_NH_BMASS",
   "type": "double",
   "default": null,
   "unit": "atomic unit",
   "example": "NPT_NH_BMASS: 5000",
   "description": "Gives the inertia mass for the barostat variable in NPT_NH.",
   "remark": "Applicable to NPT_NH MD_METHOD only.\nProgram will exit if NPT_NH is selected but NPT_NH_BMASS is not input",
   "allow_bool_input": false,
   "default_remark": "No default value",
   "description_raw": "Gives the inertia mass for the barostat variable in NPT\\_NH.",
   "remark_raw": "Applicable to NPT\\_NH \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.\nProgram will exit if NPT\\_NH is selected but NPT\\_NH\\_BMASS is not input",
   "category": "qmd"
  },
  "NPT_NH_QMASS": {
   "symbol": "NPT_NH_QMASS",
   "label": "NPT_NH_QMASS",
   "type": "other",
   "default": null,
   "unit": "atomic unit",
   "example": "NPT_NH_QMASS: 2\n;700.0\n;700.0",
   "description": "Gives the amount (first number) and inertia masses (others) of thermostats in NPT_NH. The maximum amount of thermostat variables of the Nose-Hoover chain is 60",
   "remark": "Applicable to NPT_NH MD_METHOD only.\nProgram will exit if NPT_NH is selected but NPT_NH_QMASS is not input",
   "allow_bool_input": false,
   "default_remark": "No default value",
   "description_raw": "Gives the amount (first number) and inertia masses (others) of thermostats in NPT\\_NH. The maximum amount of thermostat variables of the Nose-Hoover chain is 60",
   "remark_raw": "Applicable to NPT\\_NH \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.\nProgram will exit if NPT\\_NH is selected but NPT\\_NH\\_QMASS is not input",
   "category": "qmd"
  },
  "NPT_NP_BMASS": {
   "symbol": "NPT_NP_BMASS",
   "label": "NPT_NP_BMASS",
   "type": "double",
   "default": null,
   "unit": "atomic unit",
   "example": "NPT_NP_BMASS: 20",
   "description": "Gives the inertia mass for the barostat variable in NPT_NP.",
   "remark": "Applicable to NPT_NP MD_METHOD only.\nProgram will exit if NPT_NP is selected but NPT_NP_BMASS is not input",
   "allow_bool_input": false,
   "default_remark": "No default value",
   "description_raw": "Gives the inertia mass for the barostat variable in NPT\\_NP.",
   "remark_raw": "Applicable to NPT\\_NP \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.\nProgram will exit if NPT\\_NP is selected but NPT\\_NP\\_BMASS is not input",
   "category": "qmd"
  },
  "NPT_NP_QMASS": {
   "symbol": "NPT_NP_QMASS",
   "label": "NPT_NP_QMASS",
   "type": "double",
   "default": null,
   "unit": "atomic unit",
   "example": "NPT_NP_QMASS: 100",
   "description": "Gives the inertia mass for the thermostat variable in NPT_NP.",
   "remark": "Applicable to NPT_NP MD_METHOD only.\nProgram will exit if NPT_NP is selected but NPT_NP_BMASS is not input",
   "allow_bool_input": false,
   "default_remark": "No default value",
   "description_raw": "Gives the inertia mass for the thermostat variable in NPT\\_NP.",
   "remark_raw": "Applicable to NPT\\_NP \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.\nProgram will exit if NPT\\_NP is selected but NPT\\_NP\\_BMASS is not input",
   "category": "qmd"
  },
  "NPT_SCALE_CONSTRAINTS": {
   "symbol": "NPT_SCALE_CONSTRAINTS",
   "label": "NPT_SCALE_CONSTRAINTS",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "NPT_SCALE_CONSTRAINTS: 12",
   "description": "Set the scale constraint for lattice vectors in NPT_NP. The length ratio between the designated lattice vector keeps constant in NPT_NP thermostat. For example, if ``12'' is set, then the length ratio between 1st and 2nd lattice vectors will keep constant.",
   "remark": "Applicable to orthogonal system using NPT_NP MD_METHOD only.\nThere are 4 types of available constraints. ``12'' or ``21''; ``13'' or ``31''; ``23'' or ``32''; ``123'' or ``132'' or ``213'' or ``231'' or ``312'' or ``321''.",
   "allow_bool_input": false,
   "default_remark": "none",
   "description_raw": "Set the scale constraint for lattice vectors in NPT\\_NP. The length ratio between the designated lattice vector keeps constant in NPT\\_NP thermostat. For example, if ``12'' is set, then the length ratio between 1st and 2nd lattice vectors will keep constant.",
   "remark_raw": "Applicable to orthogonal system using NPT\\_NP \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.\n\nThere are 4 types of available constraints. ``12'' or ``21''; ``13'' or ``31''; ``23'' or ``32''; ``123'' or ``132'' or ``213'' or ``231'' or ``312'' or ``321''.",
   "category": "qmd"
  },
  "NPT_SCALE_VECS": {
   "symbol": "NPT_SCALE_VECS",
   "label": "NPT_SCALE_VECS",
   "type": "integer array",
   "default": 1,
   "unit": "No unit",
   "example": "NPT_SCALE_VECS: 2",
   "description": "Specify which lattice vectors can be rescaled in NPT_NH and NPT_NP. The cell will only expand or shrink in the specified directions.\nRescaled vectors can be specified for orthogonal systems if NPT_NP thermostat is used.",
   "remark": "Only three numbers 1, 2 and 3 can be accepted. For example, if ``2 3'' is the input, the cell will only expand or shrink in the directions of lattice vector 2 and lattice vector 3.\nIf it is set in NPT_NH, the expansion or shrinkage on designated lattice vector will try to keep the total pressure to oscillate near the target pressure.\nIf it is set in NPT_NP, the expansion or shrinkage on designated lattice vector will only try to keep the normal stress at their direction to oscillate near the target pressure.",
   "allow_bool_input": false,
   "default_remark": "1 2 3",
   "description_raw": "Specify which lattice vectors can be rescaled in NPT\\_NH and NPT\\_NP. The cell will only expand or shrink in the specified directions.\n\nRescaled vectors can be specified for orthogonal systems if NPT\\_NP thermostat is used.",
   "remark_raw": "Only three numbers 1, 2 and 3 can be accepted. For example, if ``2 3'' is the input, the cell will only expand or shrink in the directions of lattice vector 2 and lattice vector 3.\n\nIf it is set in NPT\\_NH, the expansion or shrinkage on designated lattice vector will try to keep the total pressure to oscillate near the target pressure.\n\nIf it is set in NPT\\_NP, the expansion or shrinkage on designated lattice vector will only try to keep the normal stress at their direction to oscillate near the target pressure.",
   "category": "qmd"
  },
  "NP_BAND_PARAL": {
   "symbol": "NP_BAND_PARAL",
   "label": "NP_BAND_PARAL",
   "type": "integer",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_BAND_PARAL: 5",
   "description": "Number of band groups.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Number of band groups.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "parallelization options"
  },
  "NP_DOMAIN_PARAL": {
   "symbol": "NP_DOMAIN_PARAL",
   "label": "NP_DOMAIN_PARAL",
   "type": "integer array",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_DOMAIN_PARAL: 3 3 2",
   "description": "Dimensions of the 3D Cartesian topology embedded in each band group.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Dimensions of the 3D Cartesian topology embedded in each band group.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "parallelization options"
  },
  "NP_DOMAIN_PHI_PARAL": {
   "symbol": "NP_DOMAIN_PHI_PARAL",
   "label": "NP_DOMAIN_PHI_PARAL",
   "type": "integer array",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_DOMAIN_PHI_PARAL: 1 1 2",
   "description": "Dimensions of the 3D Cartesian topology embedded in the global communicator.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Dimensions of the 3D Cartesian topology embedded in the global communicator.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "parallelization options"
  },
  "NP_KPOINT_PARAL": {
   "symbol": "NP_KPOINT_PARAL",
   "label": "NP_KPOINT_PARAL",
   "type": "integer",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_KPOINT_PARAL: 5",
   "description": "Number of k-point groups.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Number of k-point groups.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "parallelization options"
  },
  "NP_SPIN_PARAL": {
   "symbol": "NP_SPIN_PARAL",
   "label": "NP_SPIN_PARAL",
   "type": "integer",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_SPIN_PARAL: 2",
   "description": "Number of spin groups.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Number of spin groups.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "parallelization options"
  },
  "NSTATES": {
   "symbol": "NSTATES",
   "label": "NSTATES",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "NSTATES: 24",
   "description": "The number of Kohn-Sham states/orbitals.",
   "remark": "This number should not be smaller than half of\nthe total number of valence electrons (N_e) in the system. Note that the number of additional states required increases with increasing values of ELEC_TEMP/SMEARING.",
   "allow_bool_input": false,
   "default_remark": "$N_e/2 \\times 1.2 + 5$",
   "description_raw": "The number of Kohn-Sham states/orbitals.",
   "remark_raw": "This number should not be smaller than half of\nthe total number of valence electrons ($N_e$) in the system. Note that the number of additional states required increases with increasing values of \\hyperlink{ELEC_TEMP}{\\texttt{ELEC\\_TEMP}}/\\hyperlink{SMEARING}{\\texttt{SMEARING}}.",
   "category": "system"
  },
  "NUM_CHEFSI": {
   "symbol": "NUM_CHEFSI",
   "label": "NUM_CHEFSI",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "NUM_CHEFSI: 2",
   "description": "The number of times ChefSI algorithm is repeated in SCF iteration except the first one, which is controlled by RHO_TRIGGER.",
   "remark": "For non-collinear spin calculation, it might helped SCF convergence in some cases.",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "The number of times ChefSI algorithm is repeated in SCF iteration except the first one, which is controlled by \\texttt{RHO\\_TRIGGER}.",
   "remark_raw": "For non-collinear spin calculation, it might helped SCF convergence in some cases.",
   "category": "scf"
  },
  "N_TYPE_ATOM": {
   "symbol": "N_TYPE_ATOM",
   "label": "N_TYPE_ATOM",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "N_TYPE_ATOM: 2",
   "description": "The number of atoms of a ATOM_TYPE specified immediately before this variable.",
   "remark": "For a system with different types of atoms, one has to specify the number of atoms for every type.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The number of atoms of a \\hyperlink{ATOM_TYPE}{\\texttt{ATOM\\_TYPE}} specified immediately before this variable.",
   "remark_raw": "For a system with different types of atoms, one has to specify the number of atoms for every type.",
   "category": "system"
  },
  "OFDFT_FLAG": {
   "symbol": "OFDFT_FLAG",
   "label": "OFDFT_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "OFDFT_FLAG: 1",
   "description": "Flag for Orbital-free DFT calculation.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for Orbital-free DFT calculation.",
   "remark_raw": "",
   "remark": "",
   "category": "orbital free dft"
  },
  "OFDFT_LAMBDA": {
   "symbol": "OFDFT_LAMBDA",
   "label": "OFDFT_LAMBDA",
   "type": "double",
   "default": 0.2,
   "unit": "No unit",
   "example": "OFDFT_LAMBDA: 0.3",
   "description": "The coefficient in front of Laplacian operator is -lambda/2.",
   "allow_bool_input": false,
   "default_remark": "0.2",
   "description_raw": "The coefficient in front of Laplacian operator is -lambda/2.",
   "remark_raw": "",
   "remark": "",
   "category": "orbital free dft"
  },
  "OUTPUT_FILE": {
   "symbol": "OUTPUT_FILE",
   "label": "OUTPUT_FILE",
   "type": "string",
   "default": "Same as the input file name",
   "unit": "No unit",
   "example": "OUTPUT_FILE: myfname",
   "description": "The name of the output files. The output files are attached with a suffix (`.out',`.static',`.geopt' and `.aimd').",
   "remark": "If an output file with the same name already exist, the results will be written to a file with a number attached, e.g., `myfname.out_1'. The maximum number of output files with the same name allowed is 100. After that the output files will be overwritten in succession.",
   "allow_bool_input": false,
   "default_remark": "Same as the input file name",
   "description_raw": "The name of the output files. The output files are attached with a suffix (`.out',`.static',`.geopt' and `.aimd').",
   "remark_raw": "If an output file with the same name already exist, the results will be written to a file with a number attached, e.g., `myfname.out\\_1'. The maximum number of output files with the same name allowed is 100. After that the output files will be overwritten in succession.",
   "category": "print options"
  },
  "PRECOND_KERKER_KTF": {
   "symbol": "PRECOND_KERKER_KTF",
   "label": "PRECOND_KERKER_KTF",
   "type": "double",
   "default": 1.0,
   "unit": "$\\textrm{Bohr}^{-1}$",
   "example": "PRECOND_KERKER_KTF: 0.8",
   "description": "The Thomas-Fermi screening length appearing in the kerker preconditioner (MIXING_PRECOND).",
   "allow_bool_input": false,
   "default_remark": "1.0",
   "description_raw": "The Thomas-Fermi screening length appearing in the \\texttt{kerker} preconditioner (\\hyperlink{MIXING_PRECOND}{\\texttt{MIXING\\_PRECOND}}).",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "PRECOND_KERKER_KTF_MAG": {
   "symbol": "PRECOND_KERKER_KTF_MAG",
   "label": "PRECOND_KERKER_KTF_MAG",
   "type": "double",
   "default": 1.0,
   "unit": "$\\textrm{Bohr}^{-1}$",
   "example": "PRECOND_KERKER_KTF_MAG: 0.8",
   "description": "The Thomas-Fermi screening length appearing in the kerker preconditioner for the magnetization density (MIXING_PRECOND_MAG).",
   "allow_bool_input": false,
   "default_remark": "1.0",
   "description_raw": "The Thomas-Fermi screening length appearing in the \\texttt{kerker} preconditioner for the magnetization density (\\hyperlink{MIXING_PRECOND_MAG}{\\texttt{MIXING\\_PRECOND\\_MAG}}).",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "PRECOND_KERKER_THRESH": {
   "symbol": "PRECOND_KERKER_THRESH",
   "label": "PRECOND_KERKER_THRESH",
   "type": "double",
   "default": 0.1,
   "unit": "No unit",
   "example": "PRECOND_KERKER_THRESH: 0.0",
   "description": "The threshold for the kerker preconditioner (MIXING_PRECOND).",
   "remark": "This threshold will be scaled by the MIXING_PARAMETER. If the threshold is set to 0, the original kerker preconditioner is recovered.",
   "allow_bool_input": false,
   "default_remark": "0.1",
   "description_raw": "The threshold for the \\texttt{kerker} preconditioner (\\hyperlink{MIXING_PRECOND}{\\texttt{MIXING\\_PRECOND}}).",
   "remark_raw": "This threshold will be scaled by the \\hyperlink{MIXING_PARAMETER}{\\texttt{MIXING\\_PARAMETER}}. If the threshold is set to 0, the original \\texttt{kerker} preconditioner is recovered.",
   "category": "scf"
  },
  "PRECOND_KERKER_THRESH_MAG": {
   "symbol": "PRECOND_KERKER_THRESH_MAG",
   "label": "PRECOND_KERKER_THRESH_MAG",
   "type": "double",
   "default": 0.1,
   "unit": "No unit",
   "example": "PRECOND_KERKER_THRESH_MAG: 0.0",
   "description": "The threshold for the kerker preconditioner the magnetization density (MIXING_PRECOND_MAG).",
   "remark": "This threshold will be scaled by the MIXING_PARAMETER_MAG. If the threshold is set to 0, the original kerker preconditioner is recovered.",
   "allow_bool_input": false,
   "default_remark": "0.1",
   "description_raw": "The threshold for the \\texttt{kerker} preconditioner the magnetization density (\\hyperlink{MIXING_PRECOND_MAG}{\\texttt{MIXING\\_PRECOND\\_MAG}}).",
   "remark_raw": "This threshold will be scaled by the \\hyperlink{MIXING_PARAMETER_MAG}{\\texttt{MIXING\\_PARAMETER\\_MAG}}. If the threshold is set to 0, the original \\texttt{kerker} preconditioner is recovered.",
   "category": "scf"
  },
  "PRINT_ATOMS": {
   "symbol": "PRINT_ATOMS",
   "label": "PRINT_ATOMS",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_ATOMS: 1",
   "description": "Flag for writing the atomic positions. For ground-state calculations, atom positions are printed to a `.static' output file. For structural relaxation calculations, atom positions are printed to a `.geopt' file. For QMD calculations, atom positions are printed to a `.aimd' file.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing the atomic positions. For ground-state calculations, atom positions are printed to a `.static' output file. For structural relaxation calculations, atom positions are printed to a `.geopt' file. For QMD calculations, atom positions are printed to a `.aimd' file.",
   "remark_raw": "",
   "remark": "",
   "category": "print options"
  },
  "PRINT_DENSITY": {
   "symbol": "PRINT_DENSITY",
   "label": "PRINT_DENSITY",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_DENSITY: 1",
   "description": "Flag for writing electron density into cube format. For spin-unpolarized calculation, electron density is printed into .dens file. For collinear spin calculation, total, spin-up and spin-down electron density are printed into .dens, .densUp and .densDwn file, respectively.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing electron density into cube format. For spin-unpolarized calculation, electron density is printed into .dens file. For collinear spin calculation, total, spin-up and spin-down electron density are printed into .dens, .densUp and .densDwn file, respectively.",
   "remark_raw": "",
   "remark": "",
   "category": "print options"
  },
  "PRINT_EIGEN": {
   "symbol": "PRINT_EIGEN",
   "label": "PRINT_EIGEN",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_EIGEN: 1",
   "description": "Flag for writing eigenvalues and occupations into .eigen file.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing eigenvalues and occupations into .eigen file.",
   "remark_raw": "",
   "remark": "",
   "category": "print options"
  },
  "PRINT_ENERGY_DENSITY": {
   "symbol": "PRINT_ENERGY_DENSITY",
   "label": "PRINT_ENERGY_DENSITY",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_ENERGY_DENSITY: 1",
   "description": "Flag for writing a few energy densities into cube format. Currently, only kinetic energy density, exchange correlation energy density (without exact exchange contribution) and exact exchange energy density (if any) are implemented.",
   "remark": "For spin-unpolarized calculation, kinetic energy density is written into .kedens, exchange correlation energy density is written into .xcedens, and exact exchange energy density is written into .exxedens. For collinear spin calculation, total, spin-up, spin-down kinetic energy density are written into .kedens, kedensUp, kedensDwn files, total, spin-up, spin-down exact exchange energy density are writted into .exxedens, .exxedensUp, .exxedensDwn files, respectively.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing a few energy densities into cube format. Currently, only kinetic energy density, exchange correlation energy density (without exact exchange contribution) and exact exchange energy density (if any) are implemented.",
   "remark_raw": "For spin-unpolarized calculation, kinetic energy density is written into .kedens, exchange correlation energy density is written into .xcedens, and exact exchange energy density is written into .exxedens. For collinear spin calculation, total, spin-up, spin-down kinetic energy density are written into .kedens, kedensUp, kedensDwn files, total, spin-up, spin-down exact exchange energy density are writted into .exxedens, .exxedensUp, .exxedensDwn files, respectively.",
   "category": "print options"
  },
  "PRINT_FORCES": {
   "symbol": "PRINT_FORCES",
   "label": "PRINT_FORCES",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_FORCES: 1",
   "description": "Flag for writing the atomic forces. For ground-state calculations, forces are printed to a `.static' output file. For structural relaxation calculations, forces are printed to a `.geopt' file. For QMD calculations, forces are printed to a `.aimd' file.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing the atomic forces. For ground-state calculations, forces are printed to a `.static' output file. For structural relaxation calculations, forces are printed to a `.geopt' file. For QMD calculations, forces are printed to a `.aimd' file.",
   "remark_raw": "",
   "remark": "",
   "category": "print options"
  },
  "PRINT_MDOUT": {
   "symbol": "PRINT_MDOUT",
   "label": "PRINT_MDOUT",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PRINT_MDOUT: 0",
   "description": "Flag for printing the the QMD output into the .aimd file.",
   "remark": "",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for printing the the QMD output into the .aimd file.",
   "remark_raw": "%",
   "category": "print options"
  },
  "PRINT_ORBITAL": {
   "symbol": "PRINT_ORBITAL",
   "label": "PRINT_ORBITAL",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PRINT_ORBITAL: 1",
   "description": "Flag for writing Kohn-Sham orbitals into a binary file.",
   "remark": "It consists of headers with system information and the orbitals. \nFirst define a few variables and their types. \n\\begintable[]\n\\begintabular|m1.8cm|m2cm|m6.3cm|\n\\hline\nname         & type, length       & description                                                                                                   \n \\hline\nNx Ny Nz     & int, 1             & Number of FD nodes in x,y,z directions                                                                        \n \\hline\nNd           & int, 1             & Total number of FD nodes                                                                                      \n \\hline\ndx, dy,dz    & double, 1         & mesh size in x,y,z directions                                                                                 \n \\hline\ndV           & double, 1          & unit Volume                                                                                                   \n \\hline\nNspinor      & int, 2             & Number of spinor in orbitals                                                                                  \n \\hline\nisReal       & int, 1             & Flag for orbitals being real or complex                                                                       \n \\hline\nnspin        & int, 1             & Number of spin channel printed                                                                                \n \\hline\nnkpt         & int, 1             & Number of k-point printed                                                                                     \n \\hline\n\\endtabular\n\\endtable",
   "remark -- cont.": "\\begin{algorithm}[H]\n\\begin{algorithmic}\n\\For{ispin = 1:nspin}\n\\For{ikpt = 1:nkpt}\n\\For{iband = 1:nband}\n    \\State spin\\_index, kpt\\_index, kpt\\_vec, band\\_index\n    \\If{isReal == 1}\n        \\State psi\\_real\n    \\Else\n        \\State psi\\_complex\n    \\EndIf\n\\EndFor\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for writing Kohn-Sham orbitals into a binary file.",
   "remark_raw": "It consists of headers with system information and the orbitals. \nFirst define a few variables and their types. \n\\begin{table}[]\n\\begin{tabular}{|m{1.8cm}|m{2cm}|m{6.3cm}|}\n\\hline\nname         & type, length       & description                                                                                                   \\\\ \\hline\nNx Ny Nz     & int, 1             & Number of FD nodes in x,y,z directions                                                                        \\\\ \\hline\nNd           & int, 1             & Total number of FD nodes                                                                                      \\\\ \\hline\ndx, dy,dz    & double, 1         & mesh size in x,y,z directions                                                                                 \\\\ \\hline\ndV           & double, 1          & unit Volume                                                                                                   \\\\ \\hline\nNspinor      & int, 2             & Number of spinor in orbitals                                                                                  \\\\ \\hline\nisReal       & int, 1             & Flag for orbitals being real or complex                                                                       \\\\ \\hline\nnspin        & int, 1             & Number of spin channel printed                                                                                \\\\ \\hline\nnkpt         & int, 1             & Number of k-point printed                                                                                     \\\\ \\hline\n\\end{tabular}\n\\end{table}",
   "category": "print options"
  },
  "PRINT_RELAXOUT": {
   "symbol": "PRINT_RELAXOUT",
   "label": "PRINT_RELAXOUT",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PRINT_RELAXOUT: 0",
   "description": "Flag for printing the structural relaxation data in a .geopt file.",
   "remark": "Required only if RELAX_FLAG is greater than 0.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for printing the structural relaxation data in a .geopt file.",
   "remark_raw": "Required only if \\hyperlink{RELAX_FLAG}{\\texttt{RELAX\\_FLAG}} is greater than $0$.",
   "category": "print options"
  },
  "PRINT_RESTART": {
   "symbol": "PRINT_RESTART",
   "label": "PRINT_RESTART",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PRINT_RESTART: 0",
   "description": "Flag for writing the .restart file, used to restart QMD and structural relaxation simulations.",
   "remark": "Relevant only if either MD_FLAG is 1 or RELAX_FLAG is 1.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for writing the .restart file, used to restart QMD and structural relaxation simulations.",
   "remark_raw": "Relevant only if either \\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} is $1$ or \\hyperlink{RELAX_FLAG}{\\texttt{RELAX\\_FLAG}} is $1$.",
   "category": "print options"
  },
  "PRINT_RESTART_FQ": {
   "symbol": "PRINT_RESTART_FQ",
   "label": "PRINT_RESTART_FQ",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PRINT_RESTART_FQ: 10",
   "description": "Frequency at which .restart file is written in QMD and structural optimization simulations.",
   "remark": "Relevant only if either MD_FLAG is 1 or RELAX_FLAG is 1.",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "Frequency at which .restart file is written in QMD and structural optimization simulations.",
   "remark_raw": "Relevant only if either \\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} is $1$ or \\hyperlink{RELAX_FLAG}{\\texttt{RELAX\\_FLAG}} is $1$.",
   "category": "print options"
  },
  "PRINT_VELS": {
   "symbol": "PRINT_VELS",
   "label": "PRINT_VELS",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PRINT_VELS: 0",
   "description": "Flag for printing the ion velocities in an QMD simulation into the .aimd file.",
   "remark": "Relevant only if MD_FLAG is set to 1.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag for printing the ion velocities in an QMD simulation into the .aimd file.",
   "remark_raw": "Relevant only if \\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} is set to $1$.",
   "category": "print options"
  },
  "PSEUDO_POT": {
   "symbol": "PSEUDO_POT",
   "label": "PSEUDO_POT",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "PSEUDO_POT: ../psp/Fe.psp8",
   "description": "Path to the pseudopotential file.",
   "remark": "The default directory for the pseudopotential files is the same as the input files. For example, if a pseudopotential Fe.psp8 is put in the same directory as the input files, one can simply specify PSEUDO_POT: Fe.psp8.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Path to the pseudopotential file.",
   "remark_raw": "The default directory for the pseudopotential files is the same as the input files. For example, if a pseudopotential Fe.psp8 is put in the same directory as the input files, one can simply specify \\texttt{PSEUDO\\_POT: Fe.psp8}.",
   "category": "system"
  },
  "PULAY_FREQUENCY": {
   "symbol": "PULAY_FREQUENCY",
   "label": "PULAY_FREQUENCY",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "PULAY_FREQUENCY: 4",
   "description": "The frequency of Pulay mixing in Periodic Pulay.",
   "remark": "The default value of 1 corresponds to Pulay mixing.",
   "allow_bool_input": false,
   "default_remark": "1",
   "description_raw": "The frequency of Pulay mixing in Periodic Pulay.",
   "remark_raw": "The default value of 1 corresponds to Pulay mixing.",
   "category": "scf"
  },
  "PULAY_RESTART": {
   "symbol": "PULAY_RESTART",
   "label": "PULAY_RESTART",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "PULAY_RESTART: 1",
   "description": "The flag for restarting the `Periodic Pulay' mixing. If set to 0, the restarted Pulay method is turned off.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "The flag for restarting the `Periodic Pulay' mixing. If set to 0, the restarted Pulay method is turned off.",
   "remark_raw": "",
   "remark": "",
   "category": "scf"
  },
  "QMASS": {
   "symbol": "QMASS",
   "label": "QMASS",
   "type": "double",
   "default": 1653.65493345972,
   "unit": "atomic unit",
   "example": "QMASS: 100000",
   "description": "Gives the inertia factor for Nose Hoover thermostat.",
   "remark": "Applicable to NVT_NH MD_METHOD only.",
   "allow_bool_input": false,
   "default_remark": "1653.654933459720",
   "description_raw": "Gives the inertia factor for Nose Hoover thermostat.",
   "remark_raw": "Applicable to NVT\\_NH \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.",
   "category": "qmd"
  },
  "READ_INIT_DENS": {
   "symbol": "READ_INIT_DENS",
   "label": "READ_INIT_DENS",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "READ_INIT_DENS: 1",
   "description": "Flag for reading initial density guess for SCF calculation.",
   "remark": "Please use it together with INPUT_DENS_FILE",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for reading initial density guess for SCF calculation.",
   "remark_raw": "Please use it together with \\hyperlink{INPUT_DENS_FILE}{\\texttt{INPUT\\_DENS\\_FILE}}",
   "category": "scf"
  },
  "REFERENCE_CUTOFF": {
   "symbol": "REFERENCE_CUTOFF",
   "label": "REFERENCE_CUTOFF",
   "type": "double",
   "default": 0.5,
   "unit": "Bohr",
   "example": "REFERENCE_CUTOFF: 1.0",
   "description": "The cutoff radius of the reference potential used for evaluating the electrostatic correction arising from overlapping pseudocharge densities.",
   "remark": "This number should be smaller than half the smallest interatomic distance.",
   "allow_bool_input": false,
   "default_remark": "0.5",
   "description_raw": "The cutoff radius of the reference potential used for evaluating the electrostatic correction arising from overlapping pseudocharge densities.",
   "remark_raw": "This number should be smaller than half the smallest interatomic distance.",
   "category": "electrostatics"
  },
  "RELAX": {
   "symbol": "RELAX",
   "label": "RELAX",
   "type": "integer array",
   "default": [
    1,
    1,
    1
   ],
   "unit": "No unit",
   "example": "RELAX: 1 0 1 \n0 1 0",
   "description": "Atomic coordinate with the corresponding RELAX value 0 is held fixed during relaxation/QMD.",
   "allow_bool_input": true,
   "default_remark": "1 1 1",
   "description_raw": "Atomic coordinate with the corresponding \\texttt{RELAX} value 0 is held fixed during relaxation/QMD.",
   "remark_raw": "",
   "remark": "",
   "category": "system"
  },
  "RELAX_FLAG": {
   "symbol": "RELAX_FLAG",
   "label": "RELAX_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "RELAX_FLAG: 1",
   "description": "Flag for performing structural relaxation. 0 means no structural relaxation. 1 represents relaxation of atom positions. 2 represents optimization of volume with the fractional coordinates of the atoms fixed. 3 represents full optimization of the cell i.e., both atoms and cell volume are relaxed",
   "remark": "This flag should not be specified if MD_FLAG is set to 1.",
   "allow_bool_input": false,
   "default_remark": "0",
   "description_raw": "Flag for performing structural relaxation. $0$ means no structural relaxation. $1$ represents relaxation of atom positions. $2$ represents optimization of volume with the fractional coordinates of the atoms fixed. $3$ represents full optimization of the cell i.e., both atoms and cell volume are relaxed",
   "remark_raw": "This flag should not be specified if \\hyperlink{MD_FLAG}{\\texttt{MD\\_FLAG}} is set to $1$.",
   "category": "structural relaxation"
  },
  "RELAX_MAXDILAT": {
   "symbol": "RELAX_MAXDILAT",
   "label": "RELAX_MAXDILAT",
   "type": "double",
   "default": 1.06,
   "unit": "No unit",
   "example": "RELAX_MAXDILAT: 1.4",
   "description": "The maximum scaling of the volume allowed with respect to the initial volume defined by CELL and LATVEC. This will determine the upper-bound and lower-bound in the bisection method (Brent's method) for the volume optimization.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "1.06",
   "description_raw": "The maximum scaling of the volume allowed with respect to the initial volume defined by \\hyperlink{CELL}{\\texttt{CELL}} and \\hyperlink{LATVEC}{\\texttt{LATVEC}}. This will determine the upper-bound and lower-bound in the bisection method (Brent's method) for the volume optimization.",
   "remark_raw": "%",
   "category": "structural relaxation"
  },
  "RELAX_METHOD": {
   "symbol": "RELAX_METHOD",
   "label": "RELAX_METHOD",
   "type": "string",
   "default": "LBFGS",
   "unit": "No unit",
   "example": "RELAX_METHOD: NLCG",
   "description": "Specifies the algorithm for structural relaxation. The choices are `LBFGS' (limited-memory BFGS), `NLCG' (Non-linear conjugate gradient), and `FIRE' (Fast inertial relaxation engine).",
   "remark": "LBFGS is typically the best choice.",
   "allow_bool_input": false,
   "default_remark": "LBFGS",
   "description_raw": "Specifies the algorithm for structural relaxation. The choices are `LBFGS' (limited-memory BFGS), `NLCG' (Non-linear conjugate gradient), and `FIRE' (Fast inertial relaxation engine).",
   "remark_raw": "LBFGS is typically the best choice.",
   "category": "structural relaxation"
  },
  "RELAX_NITER": {
   "symbol": "RELAX_NITER",
   "label": "RELAX_NITER",
   "type": "integer",
   "default": 300,
   "unit": "No unit",
   "example": "RELAX_NITER: 25",
   "description": "Specifies the maximum number of iterations for the structural relaxation (RELAX_FLAG).",
   "remark": "If RESTART_FLAG is set to 1, then relaxation will restart from the last atomic configuration and run for maximum of RELAX_NITER iterations.",
   "allow_bool_input": false,
   "default_remark": "300",
   "description_raw": "Specifies the maximum number of iterations for the structural relaxation (\\hyperlink{RELAX_FLAG}{\\texttt{RELAX\\_FLAG}}).",
   "remark_raw": "If \\hyperlink{RESTART_FLAG}{\\texttt{RESTART\\_FLAG}} is set to $1$, then relaxation will restart from the last atomic configuration and run for maximum of \\hyperlink{RELAX_NITER}{\\texttt{RELAX\\_NITER}} iterations.",
   "category": "structural relaxation"
  },
  "RESTART_FLAG": {
   "symbol": "RESTART_FLAG",
   "label": "RESTART_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "RESTART_FLAG: 0",
   "description": "Flag for restarting quantum molecular dynamics and structural relaxation. Stores last three histories for quantum molecular dynamics simulations in .restart, .restart-0 and .restart-1 files, respectively.",
   "remark": "Restarts from the previous configuration which is stored in a .restart file. Currently, code provides restart feature for atomic relaxation and QMD only.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for restarting quantum molecular dynamics and structural relaxation. Stores last three histories for quantum molecular dynamics simulations in .restart, .restart-$0$ and .restart-$1$ files, respectively.",
   "remark_raw": "Restarts from the previous configuration which is stored in a .restart file. Currently, code provides restart feature for atomic relaxation and QMD only.",
   "category": "qmd"
  },
  "RHO_TRIGGER": {
   "symbol": "RHO_TRIGGER",
   "label": "RHO_TRIGGER",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "RHO_TRIGGER: 5",
   "description": "The number of times Chebyshev filtering is repeated before updating the electron density in the very first SCF iteration.",
   "remark": "Values smaller than the default value of 4 can result in a significant increase in the number of SCF\niterations. Larger values can sometimes reduce the number of SCF iterations. For non-collinear spin calculation, default is 6 otherwise 4. For band structure calculations, default is 10.",
   "allow_bool_input": false,
   "default_remark": "4, 6, or 10",
   "description_raw": "The number of times Chebyshev filtering is repeated before updating the electron density in the very first SCF iteration.",
   "remark_raw": "Values smaller than the default value of 4 can result in a significant increase in the number of SCF\niterations. Larger values can sometimes reduce the number of SCF iterations. For non-collinear spin calculation, default is 6 otherwise 4. For band structure calculations, default is 10.",
   "category": "scf"
  },
  "SCF_ENERGY_ACC": {
   "symbol": "SCF_ENERGY_ACC",
   "label": "SCF_ENERGY_ACC",
   "type": "double",
   "default": null,
   "unit": "Ha/atom",
   "example": "SCF_ENERGY_ACC: 1e-5",
   "description": "The tolerance on the free energy for the convergence of the SCF iteration.",
   "remark": "Only one of SCF_ENERGY_ACC, SCF_FORCE_ACC, or TOL_SCF can be specified.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The tolerance on the free energy for the convergence of the SCF iteration.",
   "remark_raw": "Only one of \\hyperlink{SCF_ENERGY_ACC}{\\texttt{SCF\\_ENERGY\\_ACC}}, \\hyperlink{SCF_FORCE_ACC}{\\texttt{SCF\\_FORCE\\_ACC}}, or \\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}} can be specified.",
   "category": "scf"
  },
  "SCF_FORCE_ACC": {
   "symbol": "SCF_FORCE_ACC",
   "label": "SCF_FORCE_ACC",
   "type": "double",
   "default": null,
   "unit": "Ha/Bohr",
   "example": "SCF_FORCE_ACC: 1e-4",
   "description": "The tolerance on the atomic forces for convergence of the SCF iteration.",
   "remark": "Only one of SCF_FORCE_ACC, TOL_SCF or SCF_ENERGY_ACC can be specified.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "The tolerance on the atomic forces for convergence of the SCF iteration.",
   "remark_raw": "Only one of \\hyperlink{SCF_FORCE_ACC}{\\texttt{SCF\\_FORCE\\_ACC}}, \\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}} or \\hyperlink{SCF_ENERGY_ACC}{\\texttt{SCF\\_ENERGY\\_ACC}} can be specified.",
   "category": "scf"
  },
  "SMEARING": {
   "symbol": "SMEARING",
   "label": "SMEARING",
   "type": "double",
   "default": null,
   "unit": "Ha",
   "example": "SMEARING: 0.001",
   "description": "Value of smearing.",
   "remark": "Equivalent to setting ELEC_TEMP (0.001 Ha = 315.775 Kelvin).",
   "allow_bool_input": false,
   "default_remark": "0.007350 for \\texttt{gaussian} \\\\\n0.003675 for \\texttt{fermi-dirac}",
   "description_raw": "Value of smearing.",
   "remark_raw": "Equivalent to setting \\hyperlink{ELEC_TEMP}{\\texttt{ELEC\\_TEMP}} (0.001 Ha = 315.775 Kelvin).",
   "category": "system"
  },
  "SOCKET_FLAG": {
   "symbol": "SOCKET_FLAG",
   "label": "SOCKET_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "SOCKET_FLAG: 1",
   "description": "Flag for starting the socket communication layer. It is equivalent to the -socket switch of command line.\n  Setting SOCKET_FLAG: 1 will disable MD_FLAG and RELAX_FLAG.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag for starting the socket communication layer. It is equivalent to the \\texttt{-socket} switch of command line.\n\n  Setting \\texttt{SOCKET\\_FLAG: 1} will disable \\texttt{MD\\_FLAG} and \\texttt{RELAX\\_FLAG}.",
   "remark_raw": "",
   "remark": "",
   "category": "socket communication"
  },
  "SOCKET_HOST": {
   "symbol": "SOCKET_HOST",
   "label": "SOCKET_HOST",
   "type": "string",
   "default": "localhost",
   "unit": "No unit",
   "example": "SOCKET_HOST: 127.0.0.1",
   "description": "Host name of the socket address that SPARC listens to.  If it's an\n  INET socket, it is the address of the interface.  For a UNIX socket,\n  it is the filename of the socket file\n  (e.g. /tmp/sparc.socket).",
   "allow_bool_input": false,
   "default_remark": "localhost",
   "description_raw": "Host name of the socket address that SPARC listens to.  If it's an\n  INET socket, it is the address of the interface.  For a UNIX socket,\n  it is the filename of the socket file\n  (e.g. \\texttt{/tmp/sparc.socket}).",
   "remark_raw": "",
   "remark": "",
   "category": "socket communication"
  },
  "SOCKET_INET": {
   "symbol": "SOCKET_INET",
   "label": "SOCKET_INET",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "SOCKET_INET: 0",
   "description": "1 for INET socket, 0 for UNIX socket. If no set in .inpt\n  file, its value is determined by the -socket address:port\n  command line switch.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "1 for INET socket, 0 for UNIX socket. If no set in \\texttt{.inpt}\n  file, its value is determined by the \\texttt{-socket address:port}\n  command line switch.",
   "remark_raw": "",
   "remark": "",
   "category": "socket communication"
  },
  "SOCKET_MAX_NITER": {
   "symbol": "SOCKET_MAX_NITER",
   "label": "SOCKET_MAX_NITER",
   "type": "integer",
   "default": 10000,
   "unit": "No unit",
   "example": "SOCKET_MAX_NITER: 10000",
   "description": "Maximum number of ionic SCF steps in the socket mode. As a socket\n  client, SPARC will terminate after SOCKET_MAX_NITER steps\n  are called.",
   "allow_bool_input": false,
   "default_remark": "10000",
   "description_raw": "Maximum number of ionic SCF steps in the socket mode. As a socket\n  client, SPARC will terminate after \\texttt{SOCKET\\_MAX\\_NITER} steps\n  are called.",
   "remark_raw": "",
   "remark": "",
   "category": "socket communication"
  },
  "SOCKET_PORT": {
   "symbol": "SOCKET_PORT",
   "label": "SOCKET_PORT",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "SOCKET_PORT: 12345",
   "description": "When SPARC connects to an INET socket server, it is the port number. The SOCKET_PORT has no effect for a UNIX socket.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "When SPARC connects to an INET socket server, it is the port number. The \\texttt{SOCKET\\_PORT} has no effect for a UNIX socket.",
   "remark_raw": "",
   "remark": "",
   "category": "socket communication"
  },
  "SPIN": {
   "symbol": "SPIN",
   "label": "SPIN",
   "type": "double array",
   "default": [
    0.0
   ],
   "unit": "No unit",
   "example": "SPIN: 0 0 1.0 \n0 0 -1.0",
   "description": "Specifies the net initial spin on each atom for a spin-polarized calculation. If collinear spin used, user could use either 1 column of data for z-direction of each atom, or 3 columns of data with 0 on the first 2 columns (x,y-directions). For noncollinear spin, use need to use 3 columns of data for all directions.",
   "allow_bool_input": false,
   "default_remark": "0.0",
   "description_raw": "Specifies the net initial spin on each atom for a spin-polarized calculation. If collinear spin used, user could use either 1 column of data for z-direction of each atom, or 3 columns of data with 0 on the first 2 columns (x,y-directions). For noncollinear spin, use need to use 3 columns of data for all directions.",
   "remark_raw": "",
   "remark": "",
   "category": "system"
  },
  "SPIN_TYP": {
   "symbol": "SPIN_TYP",
   "label": "SPIN_TYP",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "SPIN_TYP: 1",
   "description": "SPIN_TYP: 0 performs spin unpolarized calculation. \nSPIN_TYP: 1 performs unconstrained collinear spin-polarized calculation.  \nSPIN_TYP: 1 performs unconstrained noncollinear spin-polarized calculation.",
   "remark": "SPIN_TYP can only take values 0, 1, 2. For collinear calculation, non-relativistic pseudopotential need to be used. For noncollinear calculation, fully relativistic pseudopotentiail need to be used.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "\\texttt{SPIN\\_TYP}: 0 performs spin unpolarized calculation. \\\\\n\\texttt{SPIN\\_TYP}: 1 performs unconstrained collinear spin-polarized calculation.  \\\\\n\\texttt{SPIN\\_TYP}: 1 performs unconstrained noncollinear spin-polarized calculation.",
   "remark_raw": "\\texttt{SPIN\\_TYP} can only take values 0, 1, 2. For collinear calculation, non-relativistic pseudopotential need to be used. For noncollinear calculation, fully relativistic pseudopotentiail need to be used.",
   "category": "system"
  },
  "TARGET_PRESSURE": {
   "symbol": "TARGET_PRESSURE",
   "label": "TARGET_PRESSURE",
   "type": "double",
   "default": 0.0,
   "unit": "GPa",
   "example": "TARGET_PRESSURE: 40.9611",
   "description": "Gives the outer pressure in NPT_NH and NPT_NP.",
   "remark": "Applicable to NPT_NH and NPT_NP MD_METHOD only.",
   "allow_bool_input": false,
   "default_remark": "0.0",
   "description_raw": "Gives the outer pressure in NPT\\_NH and NPT\\_NP.",
   "remark_raw": "Applicable to NPT\\_NH and NPT\\_NP \\hyperlink{MD_METHOD}{\\texttt{MD\\_METHOD}} only.",
   "category": "qmd"
  },
  "TOL_FOCK": {
   "symbol": "TOL_FOCK",
   "label": "TOL_FOCK",
   "type": "double",
   "default": "auto",
   "unit": "No unit",
   "example": "TOL_FOCK: 1e-6",
   "description": "The tolerance on the Hartree-Fock outer loop, measured by the difference between the band energy in 2 consecutive outer loops.",
   "remark": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "allow_bool_input": false,
   "default_remark": "Automatically set for $10^{-3}$ Ha/Bohr accuracy in force",
   "description_raw": "The tolerance on the Hartree-Fock outer loop, measured by the difference between the band energy in 2 consecutive outer loops.",
   "remark_raw": "Only active when using hybrid functionals, like PBE0 and HSE.",
   "category": "scf"
  },
  "TOL_LANCZOS": {
   "symbol": "TOL_LANCZOS",
   "label": "TOL_LANCZOS",
   "type": "double",
   "default": 0.01,
   "unit": "No unit",
   "example": "TOL_LANCZOS: 1e-3",
   "description": "The tolerance within the Lanczos algorithm for calculating the extremal eigenvalues of the Hamiltonian, required as part of the CheFSI method.",
   "remark": "Typically, the Lanczos tolerance does not need to be very strict.",
   "allow_bool_input": false,
   "default_remark": "1e-2",
   "description_raw": "The tolerance within the Lanczos algorithm for calculating the extremal eigenvalues of the Hamiltonian, required as part of the CheFSI method.",
   "remark_raw": "Typically, the Lanczos tolerance does not need to be very strict.",
   "category": "scf"
  },
  "TOL_OFDFT": {
   "symbol": "TOL_OFDFT",
   "label": "TOL_OFDFT",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_OFDFT: 1E-6",
   "description": "The tolerance on the normalized residual (l2-norm of residual/sqrt(N), N is number of nodes) for convergence of NLCG.",
   "allow_bool_input": false,
   "default_remark": "$10^{-3}$",
   "description_raw": "The tolerance on the normalized residual (l2-norm of residual/sqrt(N), N is number of nodes) for convergence of NLCG.",
   "remark_raw": "",
   "remark": "",
   "category": "orbital free dft"
  },
  "TOL_POISSON": {
   "symbol": "TOL_POISSON",
   "label": "TOL_POISSON",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_POISSON: 1e-6",
   "description": "The tolerance on the norm of the relative residual for the Poisson equation.",
   "remark": "The tolerance for poisson solver should not be worse than TOL_SCF, otherwise it might seriously affect  the convergence of the SCF iteration.",
   "allow_bool_input": false,
   "default_remark": "\\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}}$\\times 0.01$",
   "description_raw": "The tolerance on the norm of the relative residual for the Poisson equation.",
   "remark_raw": "The tolerance for poisson solver should not be worse than \\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}}, otherwise it might seriously affect  the convergence of the SCF iteration.",
   "category": "electrostatics"
  },
  "TOL_PRECOND": {
   "symbol": "TOL_PRECOND",
   "label": "TOL_PRECOND",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_PRECOND: 1e-4",
   "description": "The tolerance on the relative residual for the linear systems arising during the real-space preconditioning of the SCF.",
   "remark": "The linear systems do not need to be solved very accurately. h is the mesh spacing.",
   "allow_bool_input": false,
   "default_remark": "$h^2\\times0.001$",
   "description_raw": "The tolerance on the relative residual for the linear systems arising during the real-space preconditioning of the SCF.",
   "remark_raw": "The linear systems do not need to be solved very accurately. $h$ is the mesh spacing.",
   "category": "scf"
  },
  "TOL_PSEUDOCHARGE": {
   "symbol": "TOL_PSEUDOCHARGE",
   "label": "TOL_PSEUDOCHARGE",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_PSEUDOCHARGE: 1e-6",
   "description": "The error in the net enclosed charge for the pseudocharge density of each atom.",
   "allow_bool_input": false,
   "default_remark": "\\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}}$\\times 0.001$",
   "description_raw": "The error in the net enclosed charge for the pseudocharge density of each atom.",
   "remark_raw": "",
   "remark": "",
   "category": "electrostatics"
  },
  "TOL_RELAX": {
   "symbol": "TOL_RELAX",
   "label": "TOL_RELAX",
   "type": "double",
   "default": 0.0005,
   "unit": "Ha/Bohr",
   "example": "TOL_RELAX: 1e-3",
   "description": "Specifies the tolerance for termination of the structural relaxation. The tolerance is defined on the maximum force component (in absolute sense) over all atoms.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "5e-4",
   "description_raw": "Specifies the tolerance for termination of the structural relaxation. The tolerance is defined on the maximum force component (in absolute sense) over all atoms.",
   "remark_raw": "%",
   "category": "structural relaxation"
  },
  "TOL_RELAX_CELL": {
   "symbol": "TOL_RELAX_CELL",
   "label": "TOL_RELAX_CELL",
   "type": "double",
   "default": 0.01,
   "unit": "GPa",
   "example": "TOL_RELAX: 1e-3",
   "description": "Specifies the tolerance for termination of the cell relaxation. The tolerance is defined on the maximum principle stress component.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "1e-2",
   "description_raw": "Specifies the tolerance for termination of the cell relaxation. The tolerance is defined on the maximum principle stress component.",
   "remark_raw": "%",
   "category": "structural relaxation"
  },
  "TOL_SCF": {
   "symbol": "TOL_SCF",
   "label": "TOL_SCF",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_SCF: 1e-5",
   "description": "In case of single point calculation, TOL_SCF is set for 10^-5 Ha/atom energy accuracy.\nIn case of MD, TOL_SCF is set for 10^-3 Ha/Bohr force accuracy.\nIn case of relaxation, TOL_SCF is set for TOL_RELAX/5 Ha/Bohr force accuracy. \nThe tolerance on the normalized residual of the effective potential or the electron density for convergence of the SCF iteration.",
   "remark": "Only one of TOL_SCF, SCF_ENERGY_ACC, or SCF_FORCE_ACC can be specified.",
   "allow_bool_input": false,
   "default_remark": "see description",
   "description_raw": "In case of single point calculation, \\texttt{TOL\\_SCF} is set for $10^{-5}$ Ha/atom energy accuracy.\nIn case of MD, \\texttt{TOL\\_SCF} is set for $10^{-3}$ Ha/Bohr force accuracy.\nIn case of relaxation, \\texttt{TOL\\_SCF} is set for \\hyperlink{TOL_RELAX}{\\texttt{TOL\\_RELAX}}/5 Ha/Bohr force accuracy. \\\\\nThe tolerance on the normalized residual of the effective potential or the electron density for convergence of the SCF iteration.",
   "remark_raw": "Only one of \\hyperlink{TOL_SCF}{\\texttt{TOL\\_SCF}}, \\hyperlink{SCF_ENERGY_ACC}{\\texttt{SCF\\_ENERGY\\_ACC}}, or \\hyperlink{SCF_FORCE_ACC}{\\texttt{SCF\\_FORCE\\_ACC}} can be specified.",
   "category": "scf"
  },
  "TOL_SCF_INIT": {
   "symbol": "TOL_SCF_INIT",
   "label": "TOL_SCF_INIT",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "TOL_SCF_INIT: 1e-6",
   "description": "The initial SCF tolerance for PBE iteration when using hybrid functionals.",
   "remark": "Only active when using hybrid functionals, like PBE0 and HSE. Change the TOL_SCF_INIT to change the initial guess for Hartree Fock outer loop.",
   "allow_bool_input": false,
   "default_remark": "$\\max($\\hyperlink{TOL_FOCK}{\\texttt{TOL\\_FOCK}}$\\times 10,0.001)$",
   "description_raw": "The initial SCF tolerance for PBE iteration when using hybrid functionals.",
   "remark_raw": "Only active when using hybrid functionals, like PBE0 and HSE. Change the \\texttt{TOL\\_SCF\\_INIT} to change the initial guess for Hartree Fock outer loop.",
   "category": "scf"
  },
  "TWTIME": {
   "symbol": "TWTIME",
   "label": "TWTIME",
   "type": "double",
   "default": 1000000000.0,
   "unit": "min",
   "example": "TWTIME: 1000",
   "description": "Gives the upper bound on the wall time for quantum molecular dynamics.",
   "allow_bool_input": false,
   "default_remark": "1e9",
   "description_raw": "Gives the upper bound on the wall time for quantum molecular dynamics.",
   "remark_raw": "",
   "remark": "",
   "category": "qmd"
  },
  "NP_DOMAIN_SQ_PARAL": {
   "symbol": "NP_DOMAIN_SQ_PARAL",
   "label": "NP_DOMAIN_SQ_PARAL",
   "type": "integer array",
   "default": "auto",
   "unit": "No unit",
   "example": "NP_DOMAIN_SQ_PARAL: 3 3 2",
   "description": "Dimensions of the 3D Cartesian topology for SQ method.",
   "remark": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "allow_bool_input": false,
   "default_remark": "Automatically optimized",
   "description_raw": "Dimensions of the 3D Cartesian topology for SQ method.",
   "remark_raw": "This option is for development purpose. It's better to let SPARC choose the parallization parameters in practice.",
   "category": "spectral quadrature"
  },
  "SQ_AMBIENT_FLAG": {
   "symbol": "SQ_AMBIENT_FLAG",
   "label": "SQ_AMBIENT_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "SQ_AMBIENT_FLAG: 1",
   "description": "Flag to turn on SQ method",
   "remark": "SQ method can not be turned on simultaneously with CS, SQ3, hybrid functionals.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to turn on SQ method",
   "remark_raw": "SQ method can not be turned on simultaneously with CS, SQ3, hybrid functionals.",
   "category": "spectral quadrature"
  },
  "SQ_HIGHT_FLAG": {
   "symbol": "SQ_HIGHT_FLAG",
   "label": "SQ_HIGHT_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "SQ_HIGHT_FLAG: 1",
   "description": "Flag to turn on SQ method for High Temperature",
   "remark": "At High Temperature, spin-polarized calculation is not supported and high memory usage is always enabled.\nTo use Low Temperature SQ method, please turn it off by setting SQ_HIGHT_FLAG: 0.",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to turn on SQ method for High Temperature",
   "remark_raw": "At High Temperature, spin-polarized calculation is not supported and high memory usage is always enabled.\nTo use Low Temperature SQ method, please turn it off by setting SQ\\_HIGHT\\_FLAG: 0.",
   "category": "spectral quadrature"
  },
  "SQ_HIGHT_GAUSS_HYBRID_MEM": {
   "symbol": "SQ_HIGHT_GAUSS_HYBRID_MEM",
   "label": "SQ_HIGHT_GAUSS_HYBRID_MEM",
   "type": "string",
   "default": "LOW",
   "unit": "No unit",
   "example": "SQ_HIGHT_GAUSS_HYBRID_MEM: HIGH",
   "description": "Flag for memory option when using Gauss quadrature at High Temperature for saving the exact exchange potential when using hybrid functionals.",
   "allow_bool_input": false,
   "default_remark": "LOW",
   "description_raw": "Flag for memory option when using Gauss quadrature at High Temperature for saving the exact exchange potential when using hybrid functionals.",
   "remark_raw": "",
   "remark": "",
   "category": "spectral quadrature"
  },
  "SQ_NPL_G": {
   "symbol": "SQ_NPL_G",
   "label": "SQ_NPL_G",
   "type": "integer",
   "default": null,
   "unit": "No unit",
   "example": "SQ_NPL_G: 24",
   "description": "Degree of polynomial for Gauss Quadrature.",
   "remark": "SQ_NPL_G must be specified if SQ is turned on.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Degree of polynomial for Gauss Quadrature.",
   "remark_raw": "\\texttt{SQ\\_NPL\\_G} must be specified if SQ is turned on.",
   "category": "spectral quadrature"
  },
  "SQ_RCUT": {
   "symbol": "{SQ_RCUT",
   "label": "SQ_RCUT",
   "type": "double",
   "default": null,
   "unit": "Bohr",
   "example": "SQ_RCUT: 2.0",
   "description": "Truncation or localization radius",
   "remark": "SQ_RCUT must be specified if SQ is turned on.",
   "allow_bool_input": false,
   "default_remark": "None",
   "description_raw": "Truncation or localization radius",
   "remark_raw": "\\texttt{{SQ\\_RCUT}} must be specified if SQ is turned on.",
   "category": "spectral quadrature"
  },
  "SQ_TOL_OCC": {
   "symbol": "SQ_TOL_OCC",
   "label": "SQ_TOL_OCC",
   "type": "double",
   "default": null,
   "unit": "No unit",
   "example": "SQ_TOL_OCC: 1E-5",
   "description": "Tolerance for occupation corresponding to maximum eigenvalue.",
   "allow_bool_input": false,
   "default_remark": "$10^{-6}$",
   "description_raw": "Tolerance for occupation corresponding to maximum eigenvalue.",
   "remark_raw": "",
   "remark": "",
   "category": "spectral quadrature"
  },
  "TWIST_ANGLE": {
   "symbol": "TWIST_ANGLE",
   "label": "TWIST_ANGLE",
   "type": "double",
   "default": 0.0,
   "unit": "rad/Bohr",
   "example": "TWIST_ANGLE: 0.0045",
   "description": "External twist per unit length applied on the nanotube.",
   "remark": "If using helical symmetry (D C H), we also have to add the intrinsic twist.",
   "allow_bool_input": false,
   "default_remark": "0",
   "description_raw": "External twist per unit length applied on the nanotube.",
   "remark_raw": "If using helical symmetry (D C H), we also have to add the intrinsic twist.",
   "category": "cyclix"
  },
  "MLFF_ANGULAR_BASIS": {
   "symbol": "{MLFF_ANGULAR_BASIS",
   "label": "MLFF_ANGULAR_BASIS",
   "type": "integer",
   "default": 6,
   "unit": "No unit",
   "example": "MLFF_ANGULAR_BASIS: 7",
   "description": "The maximum angular momentum quantum number (L) of spherical harmonics used in the SOAP descriptor.",
   "remark": "6-8 for SOAP works well for most applications.",
   "allow_bool_input": false,
   "default_remark": "6",
   "description_raw": "The maximum angular momentum quantum number (L) of spherical harmonics used in the SOAP descriptor.",
   "remark_raw": "6-8 for SOAP works well for most applications.",
   "category": "mlff"
  },
  "MLFF_DFT_FQ": {
   "symbol": "{MLFF_DFT_FQ",
   "label": "MLFF_DFT_FQ",
   "type": "integer",
   "default": 100000000,
   "unit": "No unit",
   "example": "MLFF_DFT_FQ: 100",
   "description": "Input variable to set the frequency at which DFT must be performed during on-the-fly MD.",
   "allow_bool_input": false,
   "default_remark": "100000000",
   "description_raw": "Input variable to set the frequency at which DFT must be performed during on-the-fly MD.",
   "remark_raw": "",
   "remark": "",
   "category": "mlff"
  },
  "MLFF_EXPONENT_SOAP": {
   "symbol": "{MLFF_EXPONENT_SOAP",
   "label": "MLFF_EXPONENT_SOAP",
   "type": "double",
   "default": 4.0,
   "unit": "No unit",
   "example": "MLFF_EXPONENT_SOAP: 4.0",
   "description": "The exponent in the polynomial kernel used in Bayesian linear regression.",
   "remark": "In principle, any number greater than 1 could be used. The code has been tested most for the exponent of 4.",
   "allow_bool_input": false,
   "default_remark": "4.0",
   "description_raw": "The exponent in the polynomial kernel used in Bayesian linear regression.",
   "remark_raw": "In principle, any number greater than 1 could be used. The code has been tested most for the exponent of 4.",
   "category": "mlff"
  },
  "MLFF_FACTOR_MULTIPLY_SIGMATOL": {
   "symbol": "{MLFF_FACTOR_MULTIPLY_SIGMATOL",
   "label": "MLFF_FACTOR_MULTIPLY_SIGMATOL",
   "type": "double",
   "default": 1.01,
   "unit": "No unit",
   "example": "MLFF_FACTOR_MULTIPLY_SIGMATOL: 1.001",
   "description": "A prefactor multiplied with maximum of Bayesian errors while updating the \\sigma_\\rm tol. It has to be greater than 1.",
   "remark": "A larger value will result lesser DFT calls hence might reduce the accuracy. Use any number in (1.0001-1.01) range.",
   "allow_bool_input": false,
   "default_remark": "1.01",
   "description_raw": "A prefactor multiplied with maximum of Bayesian errors while updating the $\\sigma_{\\rm tol}$. It has to be greater than 1.",
   "remark_raw": "A larger value will result lesser DFT calls hence might reduce the accuracy. Use any number in (1.0001-1.01) range.",
   "category": "mlff"
  },
  "MLFF_FLAG": {
   "symbol": "MLFF_FLAG",
   "label": "MLFF_FLAG",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "MLFF_FLAG: 1",
   "description": "Flag to turn on MLFF in SPARC. There are three options currently available. (1) MLFF_FLAG: 1 to perform on-the-fly MD with no existing model, (2) MLFF_FLAG: 21 to perform only predictions from an existing model, and (3) MLFF_FLAG: 22 to perform on-the-fly MD building on top of an existing model",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to turn on MLFF in SPARC. There are three options currently available. (1) MLFF\\_FLAG: 1 to perform on-the-fly MD with no existing model, (2) MLFF\\_FLAG: 21 to perform only predictions from an existing model, and (3) MLFF\\_FLAG: 22 to perform on-the-fly MD building on top of an existing model",
   "remark_raw": "",
   "remark": "",
   "category": "mlff"
  },
  "MLFF_IF_ATOM_DATA_AVAILABLE": {
   "symbol": "{MLFF_IF_ATOM_DATA_AVAILABLE",
   "label": "MLFF_IF_ATOM_DATA_AVAILABLE",
   "type": "integer",
   "default": 0,
   "unit": "No unit",
   "example": "MLFF_IF_ATOM_DATA_AVAILABLE: 1",
   "description": "Flag to indicate if an pretrained MLFF model is available.",
   "remark": "",
   "allow_bool_input": true,
   "default_remark": "0",
   "description_raw": "Flag to indicate if an pretrained MLFF model is available.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_IF_SPARSIFY_BEFORE_TRAIN": {
   "symbol": "{MLFF_IF_SPARSIFY_BEFORE_TRAIN",
   "label": "MLFF_IF_SPARSIFY_BEFORE_TRAIN",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "MLFF_IF_SPARSIFY_BEFORE_TRAIN: 1",
   "description": "Flag to turn on the sparsification before each of the training steps.",
   "remark": "",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag to turn on the sparsification before each of the training steps.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_INITIAL_STEPS_TRAIN": {
   "symbol": "{MLFF_INITIAL_STEPS_TRAIN",
   "label": "MLFF_INITIAL_STEPS_TRAIN",
   "type": "integer",
   "default": 10,
   "unit": "No unit",
   "example": "MLFF_INITIAL_STEPS_TRAIN: 20",
   "description": "The number of DFT steps performed in the beginning of on-the-fly MLFF simulation.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "10",
   "description_raw": "The number of DFT steps performed in the beginning of on-the-fly MLFF simulation.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_MAX_CONFIG_STORE": {
   "symbol": "{MLFF_MAX_CONFIG_STORE",
   "label": "MLFF_MAX_CONFIG_STORE",
   "type": "integer",
   "default": 5000,
   "unit": "No unit",
   "example": "MLFF_MAX_CONFIG_STORE: 1000",
   "description": "Maximum number of atomic descriptors per element type that will be used in training.",
   "remark": "A larger number requires larger memory allocation.",
   "allow_bool_input": false,
   "default_remark": "5000",
   "description_raw": "Maximum number of atomic descriptors per element type that will be used in training.",
   "remark_raw": "A larger number requires larger memory allocation.",
   "category": "mlff"
  },
  "MLFF_MAX_STR_STORE": {
   "symbol": "{MLFF_MAX_STR_STORE",
   "label": "MLFF_MAX_STR_STORE",
   "type": "integer",
   "default": 500,
   "unit": "No unit",
   "example": "MLFF_MAX_STR_STORE: 1000",
   "description": "Maximum number of DFT calls that can be made during the on-the-fly simulation.",
   "remark": "A larger number requires larger memory allocation.",
   "allow_bool_input": false,
   "default_remark": "500",
   "description_raw": "Maximum number of DFT calls that can be made during the on-the-fly simulation.",
   "remark_raw": "A larger number requires larger memory allocation.",
   "category": "mlff"
  },
  "MLFF_MODEL_FOLDER": {
   "symbol": "{MLFF_MODEL_FOLDER",
   "label": "MLFF_MODEL_FOLDER",
   "type": "string",
   "default": null,
   "unit": "No unit",
   "example": "MLFF_MODEL_FOLDER: ././",
   "description": "The location of folder where the trained model file is located.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "No default",
   "description_raw": "The location of folder where the trained model file is located.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_PRINT_FLAG": {
   "symbol": "{MLFF_PRINT_FLAG",
   "label": "MLFF_PRINT_FLAG",
   "type": "integer",
   "default": 1,
   "unit": "No unit",
   "example": "MLFF_PRINT_FLAG: 1",
   "description": "Flag to turn on the printing of MLFF related log in a file named 'mlff.log' during runtime.",
   "allow_bool_input": true,
   "default_remark": "1",
   "description_raw": "Flag to turn on the printing of MLFF related log in a file named 'mlff.log' during runtime.",
   "remark_raw": "",
   "remark": "",
   "category": "mlff"
  },
  "MLFF_RADIAL_BASIS": {
   "symbol": "{MLFF_RADIAL_BASIS",
   "label": "MLFF_RADIAL_BASIS",
   "type": "integer",
   "default": 8,
   "unit": "No unit",
   "example": "MLFF_RADIAL_BASIS: 7",
   "description": "The number of radial basis functions used in SOAP descriptors.",
   "remark": "8-10 radial basis functions should be sufficient for most applications.",
   "allow_bool_input": false,
   "default_remark": "8",
   "description_raw": "The number of radial basis functions used in SOAP descriptors.",
   "remark_raw": "8-10 radial basis functions should be sufficient for most applications.",
   "category": "mlff"
  },
  "MLFF_RCUT_SOAP": {
   "symbol": "{MLFF_RCUT_SOAP",
   "label": "MLFF_RCUT_SOAP",
   "type": "double",
   "default": 10.0,
   "unit": "Bohr",
   "example": "MLFF_RCUT_SOAP: 8.0",
   "description": "The cutoff radius used to calculate the SOAP descriptor.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "10.0",
   "description_raw": "The cutoff radius used to calculate the SOAP descriptor.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_REGUL_MIN": {
   "symbol": "{MLFF_REGUL_MIN",
   "label": "MLFF_REGUL_MIN",
   "type": "double",
   "default": 1e-14,
   "unit": "No unit",
   "example": "MLFF_REGUL_MIN: 1e-10",
   "description": "The mimimum value of inverse of condition number of K^TK + \\lambda I matrix which appear in MLFF calculation.",
   "remark": "The K^TK + \\lambda I matrix needs to be inverted during the training of MLFF. The matrix K^TK is in general ill-conditioned so regularization is used to improve the conditioning. Any number in the range of 1E-10-1E-14 should work. A larger value should result in lesser DFT calls, but also lesser accuracy of MLFF model.",
   "allow_bool_input": false,
   "default_remark": "1e-14",
   "description_raw": "The mimimum value of inverse of condition number of $K^TK + \\lambda I$ matrix which appear in MLFF calculation.",
   "remark_raw": "The $K^TK + \\lambda I$ matrix needs to be inverted during the training of MLFF. The matrix $K^TK$ is in general ill-conditioned so regularization is used to improve the conditioning. Any number in the range of 1E-10-1E-14 should work. A larger value should result in lesser DFT calls, but also lesser accuracy of MLFF model.",
   "category": "mlff"
  },
  "MLFF_SCALE_FORCE": {
   "symbol": "{MLFF_SCALE_FORCE",
   "label": "MLFF_SCALE_FORCE",
   "type": "double",
   "default": 1.0,
   "unit": "No unit",
   "example": "MLFF_SCALE_FORCE: 10",
   "description": "The scaling of force terms in the loss function during the training.",
   "remark": "A larger number can result in better accuracy of MLFF forces.",
   "allow_bool_input": false,
   "default_remark": "1.0",
   "description_raw": "The scaling of force terms in the loss function during the training.",
   "remark_raw": "A larger number can result in better accuracy of MLFF forces.",
   "category": "mlff"
  },
  "MLFF_SCALE_STRESS": {
   "symbol": "{MLFF_SCALE_STRESS",
   "label": "MLFF_SCALE_STRESS",
   "type": "double array",
   "default": [
    1.0,
    1.0,
    1.0,
    1.0,
    1.0,
    1.0
   ],
   "unit": "No unit",
   "example": "MLFF_SCALE_STRESS: 10 1 1 10 1 10",
   "description": "The scaling of stress tensor terms in the loss function during the training.",
   "remark": "",
   "allow_bool_input": false,
   "default_remark": "1.0 1.0 1.0 1.0 1.0 1.0",
   "description_raw": "The scaling of stress tensor terms in the loss function during the training.",
   "remark_raw": "%\n%",
   "category": "mlff"
  },
  "MLFF_SPLINE_NGRID": {
   "symbol": "{MLFF_SPLINE_NGRID",
   "label": "MLFF_SPLINE_NGRID",
   "type": "integer",
   "default": 100,
   "unit": "No unit",
   "example": "MLFF_SPLINE_NGRID: 100",
   "description": "Number of grid points to use for spline interpolation of hnl.",
   "remark": "A larger number can result in better accuracy of MLFF forces.",
   "allow_bool_input": false,
   "default_remark": "100",
   "description_raw": "Number of grid points to use for spline interpolation of hnl.",
   "remark_raw": "A larger number can result in better accuracy of MLFF forces.",
   "category": "mlff"
  }
 },
 "other_parameters": {},
 "data_types": [
  "double",
  "double array",
  "integer",
  "integer array",
  "other",
  "string"
 ]
}