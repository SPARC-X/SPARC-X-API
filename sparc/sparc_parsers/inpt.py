import shutil
import os
from typing import List
from collections import namedtuple
import warnings
from warnings import warn

import numpy as np
from ase import Atoms, Atom
from ase.units import Bohr
from ase.constraints import FixAtoms, FixedLine, FixedPlane

# Safe wrappers for both string and fd
from ase.utils import reader, writer

from .utils import get_label, strip_comments, bisect_and_strip, read_block_input

from ..inputs import SparcInputs

defaultAPI = SparcInputs()


@reader
def _read_inpt(fileobj):
    contents = fileobj.read()
    # label = get_label(fileobj, ".ion")
    data, comments = strip_comments(contents)
    # We do not read the cell at this time!

    # find the index for all atom type lines. They should be at the top of their block
    inpt_blocks = read_block_input(data, validator=defaultAPI)
    return {"inpt_blocks": inpt_blocks, "inpt_comments": comments}


@writer
def _write_inpt(fileobj, data_dict):
    if "inpt_blocks" not in data_dict:
        raise ValueError("Your data-dict for inpt file is empty!")

    comments = data_dict.get("inpt_comments", "")
    banner = "Input File Generated By SPARC ASE Calculator"
    if len(comments) == 0:
        comments = [banner]
    elif "ASE" not in comments[0]:
        comments = [banner] + comments
    for line in comments:
        fileobj.write(f"# {line}\n")
    fileobj.write("\n")
    blocks = data_dict["inpt_blocks"]
    for key, val in blocks.items():
        # TODO: can we add a multiline argument?
        val_string = defaultAPI.convert_value_to_string(key, val)
        if (val_string.count("\n") > 0) or (
            key
            in [
                "LATVEC",
            ]
        ):
            output = f"{key}:\n{val_string}\n"
        else:
            output = f"{key}: {val_string}\n"
        fileobj.write(output)
    return


def _inpt_cell_to_ase_cell(inpt_blocks):
    """Convert the inpt cell convention to a real cell (in ASE Angstrom unit)

    Arguments:
    inpt_blocks: an already validated inpt file blocks dict
                 (i.e. parsed by _read_inpt)
    """
    if ("CELL" in inpt_blocks) and ("LATVEC_SCALE" in inpt_blocks):
        # TODO: customize the exception class
        # TODO: how do we convert the rule from doc?
        raise ValueError("LATVEC_SCALE and CELL cannot be specified simultaneously!")

    if "CELL" in inpt_blocks:
        cell = np.eye(inpt_blocks["CELL"]) * Bohr
    elif "LATVEC" in inpt_blocks:
        lat_array = np.array(inpt_blocks["LATVEC"]) * Bohr
        if "LATVEC_SCALE" in inpt_blocks:
            scale = inpt_blocks["LATVEC_SCALE"]
            # TODO: Is this correct?
            cell = (lat_array.T * scale).T
        else:
            cell = lat_array
    else:
        # TODO: customize exception
        raise KeyError("The inpt file does not have a definition for cell!")
    return cell
