import shutil
import os
from typing import List
from collections import namedtuple
import warnings
from warnings import warn

import numpy as np
from ase import Atoms, Atom
from ase.units import Bohr
from ase.constraints import FixAtoms, FixedLine, FixedPlane

# Safe wrappers for both string and fd
from ase.utils import reader, writer

from .utils import get_label, strip_comments, bisect_and_strip, read_block_input

from ..inputs import SparcInputs

defaultAPI = SparcInputs()

@reader
def _read_inpt(fileobj):
    contents = fileobj.read()
    # label = get_label(fileobj, ".ion")
    data, comments = strip_comments(contents)
    # We do not read the cell at this time!
    
    # find the index for all atom type lines. They should be at the top of their block
    inpt_blocks = read_block_input(data, validator=defaultAPI)
    return {"inpt_blocks": inpt_blocks, "inpt_comments": comments}

@writer
def _write_inpt(fileobj, data_dict):
    if "inpt_blocks" not in data_dict:
        raise ValueError("Your data-dict for inpt file is empty!")

    comments = data_dict.get("inpt_comments", "")
    banner = "Input File Generated By SPARC ASE Calculator"
    if len(comments) == 0:
        comments = [banner]
    elif "ASE" not in comments[0]:
        comments = [banner] + comments
    for line in comments:
        fileobj.write(f"# {line}\n")
    fileobj.write("\n")
    blocks = data_dict["inpt_blocks"]
    for key, val in blocks.items():
        # TODO: can we add a multiline argument?
        val_string = defaultAPI.convert_value_to_string(key, val)
        if (val_string.count("\n") > 0) or (key in ["LATVEC", ]):
            output = f"{key}:\n{val_string}\n"
        else:
            output = f"{key}: {val_string}\n"
        fileobj.write(output)
    return
    
