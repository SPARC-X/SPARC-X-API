"""
Created on Thu Oct 18 14:16:21 2018

Ben Comer (Georgia Tech)

This file has been heavily modified since SPARC 0.1

TODO: more descriptions about this file io parser
"""
import shutil
import os
from typing import List
from collections import namedtuple
import warnings
from warnings import warn

import numpy as np
from ase import Atoms, Atom
from ase.units import Bohr
from ase.constraints import FixAtoms, FixedLine, FixedPlane

# Safe wrappers for both string and fd
from ase.utils import reader, writer

from .utils import (
    get_label,
    strip_comments,
    bisect_and_strip,
    read_block_input,
    make_reverse_mapping,
)

from ..inputs import SparcInputs
import textwrap

defaultAPI = SparcInputs()


@reader
def _read_ion(fileobj):
    """
    Read information from the .ion file. Note, this method does not return an atoms object,
    but rather return a dict. Thus the label option is not necessary to keep


    Reads an ion file. Because some of the information necessary to create
    an atoms object is found in the .inpt file, this function also attemtps to read
    that as a source of data. If the file is not found or the information is invalid,
    it will look for it in the comments of the ion file, as written.
    """
    contents = fileobj.read()
    # label = get_label(fileobj, ".ion")
    data, comments = strip_comments(contents)
    # We do not read the cell at this time!
    sort, resort = _read_sort_comment(comments)

    # find the index for all atom type lines. They should be at the top of their block
    atom_type_bounds = [i for i, x in enumerate(data) if "ATOM_TYPE" in x] + [len(data)]
    atom_blocks = [
        read_block_input(data[start:end], validator=defaultAPI)
        for start, end in zip(atom_type_bounds[:-1], atom_type_bounds[1:])
    ]

    return {
        "ion_atom_blocks": atom_blocks,
        "ion_comments": comments,
        "sorting": {"sort": sort, "resort": resort},
    }


@writer
def _write_ion(
    fileobj,
    data_dict,
):
    """
    Writes the ion file content from the atom_dict

    Please note this is not a Atoms-compatible function!

    The data_dict takes similar format as _read_ion

    Basically, we want to ensure
    data_dict = _read_ion("some.ion")
    _write_ion("some.ion", data_dict)
    shows the same format
    """
    if "ion_atom_blocks" not in data_dict:
        raise ValueError(
            "Must provide a data-section in the data_dict (blocks of atomic information)"
        )

    comments = data_dict.get("ion_comments", "")
    banner = "Ion File Generated By SPARC ASE Calculator"
    if len(comments) == 0:
        comments = ["Input File Generated By SPARC ASE Calculator"]
    elif "ASE" not in comments[0]:
        comments = [banner] + comments

    # Handle the sorting mapping
    # the line wrap is 80 words
    if "sorting" in data_dict:
        print(data_dict["sorting"])
        resort = data_dict["sorting"].get("resort", [])
        # Write resort information only when it's actually useful
        if len(resort) > 0:
            comments.append("ASE-SORT:")
            index_lines = textwrap.wrap(" ".join(map(str, resort)), width=80)
            comments.extend(index_lines)
            comments.append("END ASE-SORT")

    for line in comments:
        fileobj.write(f"# {line}\n")

    fileobj.write("\n")
    blocks = data_dict["ion_atom_blocks"]
    for block in blocks:
        for key in [
            "ATOM_TYPE",
            "N_TYPE_ATOM",
            "PSEUDO_POT",
            "COORD_FRAC",
            "COORD",
            "RELAX",
        ]:
            val = block.get(key, None)
            print(key, val)
            if (key not in ["RELAX", "COORD", "COORD_FRAC"]) and (val is None):
                raise ValueError(f"Key {key} is not provided! Abort writing ion file")
            # TODO: change the API version
            if val is None:
                continue

            val_string = defaultAPI.convert_value_to_string(key, val)
            # print(val_string)
            # TODO: make sure 1 line is accepted
            # TODO: write pads to vector lines
            if (val_string.count("\n") > 0) or (
                key in ["COORD_FRAC", "COORD", "RELAX"]
            ):
                output = f"{key}:\n{val_string}\n"
            else:
                output = f"{key}: {val_string}\n"
            fileobj.write(output)
            # TODO: check extra keys
            # TODO: how to handle multiple psp files?
        # Write a split line
        # TODO: do we need to distinguish the last line?
        fileobj.write("\n")
    return


def _ion_coord_to_ase_pos(ion_blocks, cell=None):
    """Convert the COORD or COORD_FRAC from atom blocks to ASE's positions
    Arguments:
    cell: a unit cell in ASE-unit (i.e. parsed from inpt._inpt_cell_to_ase_cell)
    """
    treated_blocks = []
    can_have_coord_frac = cell is not None

    for block in ion_blocks:
        dup_block = block.copy()
        if ("COORD" in block.keys()) and ("COORD_FRAC" in block.keys()):
            raise KeyError("COORD and COORD_FRAC cannot co-exist!")
        if (not can_have_coord_frac) and ("COORD_FRAC" in block.keys()):
            raise KeyError("COORD_FRAC must be acompanied by a cell!")
        coord = block.get("COORD", None)
        if coord is not None:
            coord = coord * Bohr
        else:
            coord_frac = block["COORD_FRAC"]
            # Cell is already in Bohr
            coord = np.dot(coord_frac, cell)
        dup_block["_ase_positions"] = coord
        treated_blocks.append(dup_block)
    return treated_blocks


def _read_sort_comment(lines):
    """Parse the atom sorting info from the comment lines
    Format

    ASE-SORT:
    r_i r_j r_k ....
    END ASE-SORT
    where r_i etc are the indices in the original ASE atoms object
    """
    i = 0
    resort = []
    record = False
    while i < len(lines):
        line = lines[i]
        key, value = bisect_and_strip(line, ":")
        i += 1
        if key == "ASE-SORT":
            record = True
        elif key == "END ASE-SORT":
            record = False
            break
        elif record is True:
            resort += list(map(int, line.strip().split(" ")))
    if record:
        warn(
            "ASE atoms resort comment block is not properly formatted, this may cause data loss!"
        )
    sort = make_reverse_mapping(resort)
    assert set(sort) == set(resort), "Sort and resort info are of different length!"
    return sort, resort


# def read_lat_array(lines):
#     lat_array = []
#     for lat_vec in lines[:3]:  # lattice vectors in next 3 lines
#         vec = np.array([float(a) for a in lat_vec.split()])
#         lat_array.append(vec / np.linalg.norm(vec))  # normalize
#     return np.array(lat_array)


# def read_inpt_cell(path):
#     lat_array = []
#     cell = []
#     with open(path, "r") as inptfile:
#         contents = inptfile.read()

#     lines = contents.splitlines()
#     for i, line in enumerate(lines):
#         if "CELL" in line:
#             cell = np.array([float(a) for a in line.split()[1:]])
#         elif "LATVEC" in line:
#             lat_array = read_lat_array(lines[i + 1 :])

#     if len(cell) == 0:
#         raise Exception(f"no cell found in {path}")
#     if len(lat_array) == 0:
#         lat_array = np.eye(3)

#     return (lat_array.T * cell).T * Bohr


# def validate_atom_block(block):
#     assert "ATOM_TYPE" in block and block["ATOM_TYPE"]
#     assert ("COORD" in block) ^ ("COORD_FRAC" in block)  # XOR
#     assert "N_TYPE_ATOM" in block
#     natoms = int(block["N_TYPE_ATOM"])
#     for key in ["COORD", "COORD_FRAC", "RELAX", "SPIN"]:
#         assert key not in block or natoms == len(block[key])

#########TO be implememted######################


def reorder(original, order):
    res = original.copy()
    for oldi, newi in enumerate(order):
        res[newi] = original[oldi]
    return res


def find_pseudo_path(element: str, pseudo_dir):
    suffix = element + ".pot"
    filenames = [a for a in os.listdir(pseudo_dir) if a.endswith(suffix)]
    if len(filenames) == 0:
        raise Exception("File not found")

    filename = filenames[0]
    if len(filenames) > 1:
        warnings.warn(
            "Multiple psudopotentials detected for "
            f"{element} ({filenames}). Using {filename}."
        )
    return os.path.join(pseudo_dir, filename)


def copy_psp(srcpath: str, dstdir: str):
    filename = os.path.basename(srcpath)
    dstpath = os.path.join(dstdir, filename)
    if srcpath != dstpath:
        shutil.copyfile(srcpath, dstpath)
